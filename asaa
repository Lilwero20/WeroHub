local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- CONFIG
local LOGO_ASSET_ID = "rbxassetid://73356133683404"
local DRAG_THRESHOLD = 8
local WHEEL_SCROLL_PIXELS = 72
local smallScreenWidthThreshold = 900
local GUI_NAME = "BackdoorHub_GUI" -- cambia si tu ScreenGui tiene otro nombre

-- Función para eliminar cualquier ScreenGui existente con el mismo nombre
local function removeExistingGui(name)
	for _, child in ipairs(playerGui:GetChildren()) do
		if child:IsA("ScreenGui") and child.Name == name then
			child:Destroy()
			warn(("Removed existing ScreenGui '%s' from PlayerGui"):format(name))
		end
	end
end

-- Llamar para limpiar antes de crear uno nuevo
removeExistingGui(GUI_NAME)

-- (Opcional) esperar un frame para asegurarnos que el Destroy() se aplicó
task.wait()

local function new(className, props)
	local obj = Instance.new(className)
	if props then
		for k,v in pairs(props) do
			if k == "Parent" then obj.Parent = v else obj[k] = v end
		end
	end
	return obj
end

local function isTouchOnly() return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled end
local function getViewport() local cam = workspace.CurrentCamera return cam and cam.ViewportSize or Vector2.new(1280,720) end

local viewport = getViewport()
local smallScreen = (math.max(viewport.X, viewport.Y) < smallScreenWidthThreshold) or isTouchOnly()
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function() viewport = getViewport(); smallScreen = (math.max(viewport.X, viewport.Y) < smallScreenWidthThreshold) or isTouchOnly() end)
UserInputService:GetPropertyChangedSignal("TouchEnabled"):Connect(function() smallScreen = (math.max(getViewport().X, getViewport().Y) < smallScreenWidthThreshold) or isTouchOnly() end)

-- Colors
local C = {
	bg = Color3.fromRGB(19,19,22),
	panel = Color3.fromRGB(30,30,36),
	item = Color3.fromRGB(38,38,44),
	text = Color3.fromRGB(236,236,240),
	subtext = Color3.fromRGB(170,170,180),
	purple = Color3.fromRGB(153,63,211),
	pink = Color3.fromRGB(236,64,122),
	toggleOn = Color3.fromRGB(200,200,255)
}

-- Create ScreenGui (force to PlayerGui)
local screenGui = new("ScreenGui", {
	Name = "BackdoorHub_GUI",
	Parent = playerGui,
	DisplayOrder = 9999,
	IgnoreGuiInset = true,
	ResetOnSpawn = false
})

-- Sizes (reduced)
local mainW = smallScreen and 520 or 720
local mainH = smallScreen and 340 or 520
local leftW = smallScreen and 160 or 220

-- OPEN BUTTON
local openBtnSize = smallScreen and 56 or 74
local openBtn = new("ImageButton", {
	Parent = screenGui,
	Name = "NH_OpenBtn",
	Image = LOGO_ASSET_ID,
	BackgroundColor3 = C.bg,
	BackgroundTransparency = 0,
	Size = UDim2.new(0, openBtnSize, 0, openBtnSize),
	Position = UDim2.new(0, 18, 0.23, -80),
	AutoButtonColor = false,
	ZIndex = 200,
	ScaleType = Enum.ScaleType.Fit
})
new("UICorner", {Parent = openBtn, CornerRadius = UDim.new(1,0)})
new("UIStroke", {Parent = openBtn, Color = C.pink, Thickness = 3})

-- MAIN OUTER & INNER
local mainOuter = new("Frame", {
	Parent = screenGui,
	Size = UDim2.new(0, mainW + 12, 0, mainH + 12),
	Position = UDim2.new(0.5, 0, 0.5, 0),
	AnchorPoint = Vector2.new(0.5, 0.5),
	BackgroundTransparency = 1,
	ZIndex = 190,
	Visible = false
})
local outline = new("Frame", {Parent = mainOuter, Size = UDim2.new(1,0,1,0), BackgroundColor3 = C.pink, BorderSizePixel = 0, ZIndex = 191})
new("UICorner", {Parent = outline, CornerRadius = UDim.new(0,16)})
local mainFrame = new("Frame", {
	Parent = outline,
	Size = UDim2.new(1,-8,1,-8),
	Position = UDim2.new(0,4,0,4),
	BackgroundColor3 = C.panel,
	BorderSizePixel = 0,
	ZIndex = 192,
	ClipsDescendants = true
})
new("UICorner", {Parent = mainFrame, CornerRadius = UDim.new(0,14)})

-- HEADER
local header = new("Frame", {Parent = mainFrame, Size = UDim2.new(1,-32,0,66), Position = UDim2.new(0,16,0,8), BackgroundTransparency = 1, ZIndex = 200})
local title = new("TextLabel", {
	Parent = header,
	Text = "Backdoor Hub",
	BackgroundTransparency = 1,
	TextColor3 = C.text,
	Font = Enum.Font.GothamBold,
	TextSize = 24,
	TextScaled = true,
	TextTransparency = 0,
	Size = UDim2.new(1,0,1,0),
	TextXAlignment = Enum.TextXAlignment.Center,
	ZIndex = 201
})
local accentLine = new("Frame", {Parent = mainFrame, Size = UDim2.new(1,-40,0,6), Position = UDim2.new(0,20,0,76), BackgroundColor3 = C.purple, BorderSizePixel = 0, ZIndex = 193})
new("UICorner", {Parent = accentLine, CornerRadius = UDim.new(0,4)})

-- CLOSE
local closeBtn = new("TextButton", {
	Parent = mainFrame,
	Text = "✕",
	Font = Enum.Font.GothamBold,
	TextSize = 20,
	TextScaled = true,
	TextTransparency = 0,
	TextColor3 = C.text,
	BackgroundColor3 = Color3.fromRGB(45,45,50),
	Size = UDim2.new(0,44,0,44),
	Position = UDim2.new(1,-64,0,12),
	AutoButtonColor = false,
	ZIndex = 202
})
new("UICorner", {Parent = closeBtn, CornerRadius = UDim.new(0,8)})
new("UIStroke", {Parent = closeBtn, Color = Color3.fromRGB(60,60,65), Thickness = 1})

-- COLUMNS
local leftCol = new("Frame", {Parent = mainFrame, Size = UDim2.new(0, leftW, 1, -110), Position = UDim2.new(0, 18, 0, 92), BackgroundColor3 = Color3.fromRGB(23,23,28), BorderSizePixel = 0, ZIndex = 193})
new("UICorner", {Parent = leftCol, CornerRadius = UDim.new(0,10)})
local divider = new("Frame", {Parent = mainFrame, Size = UDim2.new(0,6,1,-110), Position = UDim2.new(0, leftW + 26, 0, 92), BackgroundColor3 = C.purple, BorderSizePixel = 0, ZIndex = 193})
new("UICorner", {Parent = divider, CornerRadius = UDim.new(0,4)})
local rightCol = new("Frame", {Parent = mainFrame, Size = UDim2.new(1,-(leftW+60),1,-110), Position = UDim2.new(0,leftW+34,0,92), BackgroundColor3 = Color3.fromRGB(28,28,33), BorderSizePixel = 0, ClipsDescendants = true, ZIndex = 193})
new("UICorner", {Parent = rightCol, CornerRadius = UDim.new(0,10)})

-- TABS (left) - container + layout
local tabsContainer = new("Frame", {Parent = leftCol, Size = UDim2.new(1,-16,1,-16), Position = UDim2.new(0,8,0,8), BackgroundTransparency = 1, ZIndex = 195})
local tabsLayout = new("UIListLayout", {Parent = tabsContainer, Padding = UDim.new(0, 12), SortOrder = Enum.SortOrder.LayoutOrder})
tabsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
tabsLayout.VerticalAlignment = Enum.VerticalAlignment.Top

-- CONTENT (right) - mask + inner + layout
local contentMask = new("Frame", {Parent = rightCol, Size = UDim2.new(1,-24,1,-24), Position = UDim2.new(0,12,0,12), BackgroundTransparency = 1, ClipsDescendants = true, ZIndex = 195})
local contentInner = new("Frame", {Parent = contentMask, Size = UDim2.new(1,0,0,0), Position = UDim2.new(0,0,0,0), BackgroundTransparency = 1, ZIndex = 196})
local contentLayout = new("UIListLayout", {Parent = contentInner, Padding = UDim.new(0, 12), SortOrder = Enum.SortOrder.LayoutOrder})
contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left

-- When layout changes, update inner size
contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
	local sizeY = contentLayout.AbsoluteContentSize.Y
	contentInner.Size = UDim2.new(1,0,0,sizeY)
end)

-- Scroll vars
local contentOffset = 0
local function clampOffset(v)
	local maskY = contentMask.AbsoluteSize.Y
	local total = contentInner.AbsoluteSize.Y
	local max = math.max(0, total - maskY)
	if v > 0 then v = 0 end
	if v < -max then v = -max end
	return v
end
local function updateContentPos()
	contentOffset = clampOffset(contentOffset)
	contentInner.Position = UDim2.new(0,0,0,contentOffset)
end

-- TAB & TOGGLE creators
local tabsRegistry = {}
local function createTabButton(name)
	local btn = new("TextButton", {
		Parent = tabsContainer,
		Text = name,
		Font = Enum.Font.GothamSemibold,
		TextSize = 16,
		TextScaled = true,
		TextColor3 = C.text,
		Size = UDim2.new(1,-12,0,44),
		BackgroundColor3 = Color3.fromRGB(49,49,56),
		BorderSizePixel = 0,
		AutoButtonColor = false,
		ZIndex = 197
	})
	new("UICorner", {Parent = btn, CornerRadius = UDim.new(0,10)})
	new("UIStroke", {Parent = btn, Color = Color3.fromRGB(60,60,66), Thickness = 1})
	return btn
end

local function setActiveTab(name)
	for k,v in pairs(tabsRegistry) do
		local b = v.Button
		if k == name then
			b.BackgroundColor3 = C.purple
			b.TextColor3 = Color3.fromRGB(245,245,245)
		else
			b.BackgroundColor3 = Color3.fromRGB(49,49,56)
			b.TextColor3 = C.text
		end
	end
	if tabsRegistry[name] and tabsRegistry[name].onOpen then
		tabsRegistry[name].onOpen()
	end
	-- force update next frame
	RunService.Heartbeat:Wait()
	updateContentPos()
end

local function clearContent()
	for _,c in ipairs(contentInner:GetChildren()) do
		if not c:IsA("UIListLayout") then c:Destroy() end
	end
	contentInner.Size = UDim2.new(1,0,0,0)
	contentOffset = 0
	updateContentPos()
end

local function pushContentFrame(frame)
	frame.Parent = contentInner
	-- wait one frame for UIListLayout to reposition
	RunService.Heartbeat:Wait()
	updateContentPos()
end

-- Toggle creator with drag protection
local function createToggle(labelText, default, callback)
	local itemH = smallScreen and 56 or 72
	local item = new("Frame", {Size = UDim2.new(1,0,0,itemH), BackgroundColor3 = C.item, BorderSizePixel = 0, ZIndex = 196})
	new("UICorner", {Parent = item, CornerRadius = UDim.new(0,10)})

	local lbl = new("TextLabel", {
		Parent = item,
		Size = UDim2.new(0.72, -20, 1, 0),
		Position = UDim2.new(0, 12, 0, 0),
		BackgroundTransparency = 1,
		Text = labelText,
		TextColor3 = C.text,
		Font = Enum.Font.Gotham,
		TextSize = 16,
		TextScaled = true,
		TextTransparency = 0,
		TextXAlignment = Enum.TextXAlignment.Left,
		ZIndex = 197
	})
	local sub = new("TextLabel", {
		Parent = item,
		Size = UDim2.new(0.72, -20, 0, 18),
		Position = UDim2.new(0, 12, 1, -22),
		BackgroundTransparency = 1,
		Text = "",
		TextColor3 = C.subtext,
		Font = Enum.Font.Gotham,
		TextSize = 12,
		TextScaled = false,
		TextTransparency = 0,
		TextXAlignment = Enum.TextXAlignment.Left,
		ZIndex = 197
	})

	local switchW = smallScreen and 56 or 76
	local switchH = smallScreen and 28 or 36
	local switchBg = new("Frame", {
		Parent = item,
		Size = UDim2.new(0, switchW, 0, switchH),
		Position = UDim2.new(1, - (switchW + 12), 0.5, -(switchH/2)),
		BackgroundColor3 = Color3.fromRGB(80,80,86),
		BorderSizePixel = 0,
		ZIndex = 197
	})
	new("UICorner", {Parent = switchBg, CornerRadius = UDim.new(0,16)})

	local knobSize = smallScreen and 20 or 26
	local knob = new("Frame", {
		Parent = switchBg,
		Size = UDim2.new(0, knobSize, 0, knobSize),
		Position = default and UDim2.new(1, -(knobSize + 6), 0.5, -(knobSize/2)) or UDim2.new(0, 6, 0.5, -(knobSize/2)),
		BackgroundColor3 = default and C.toggleOn or Color3.fromRGB(245,245,245),
		BorderSizePixel = 0,
		ZIndex = 198
	})
	new("UICorner", {Parent = knob, CornerRadius = UDim.new(1,0)})

	local state = default
	local activeInput, startPos, isDrag, originOffset = nil, nil, false, 0

	local function began(input)
		if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
			activeInput = input
			startPos = input.Position
			isDrag = false
			originOffset = contentOffset
		end
	end
	local function changed(input)
		if activeInput and input == activeInput then
			local delta = input.Position - startPos
			if math.abs(delta.Y) > DRAG_THRESHOLD then
				isDrag = true
				contentOffset = originOffset + delta.Y
				updateContentPos()
			end
		end
	end
	local function ended(input)
		if activeInput and input == activeInput then
			if not isDrag then
				state = not state
				if state then
					knob.Position = UDim2.new(1, -(knobSize + 6), 0.5, -(knobSize/2))
					knob.BackgroundColor3 = C.toggleOn
				else
					knob.Position = UDim2.new(0, 6, 0.5, -(knobSize/2))
					knob.BackgroundColor3 = Color3.fromRGB(245,245,245)
				end
				if callback then pcall(callback, state) end
			end
			activeInput = nil; startPos = nil; isDrag = false
		end
	end

	switchBg.InputBegan:Connect(began)
	switchBg.InputChanged:Connect(changed)
	switchBg.InputEnded:Connect(ended)
	UserInputService.InputChanged:Connect(function(inp) if inp == activeInput then changed(inp) end end)
	UserInputService.InputEnded:Connect(function(inp) if inp == activeInput then ended(inp) end end)

	pushContentFrame(item)
	return {GetState = function() return state end, SetState = function(v) state = v if state then knob.Position = UDim2.new(1, -(knobSize + 6), 0.5, -(knobSize/2)); knob.BackgroundColor3 = C.toggleOn else knob.Position = UDim2.new(0, 6, 0.5, -(knobSize/2)); knob.BackgroundColor3 = Color3.fromRGB(245,245,245) end end, Frame = item}
end

-- Scroll: contentMask drag + mouse wheel
do
	local active, startY, startOffset = nil, 0, 0
	contentMask.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
			active = input; startY = input.Position.Y; startOffset = contentOffset
		end
	end)
	contentMask.InputChanged:Connect(function(input)
		if active and input == active then
			local delta = input.Position.Y - startY
			if math.abs(delta) > DRAG_THRESHOLD then
				contentOffset = startOffset + delta
				updateContentPos()
			end
		end
	end)
	contentMask.InputEnded:Connect(function(input) if active and input == active then active = nil end end)

	UserInputService.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseWheel then
			local d = input.Position.Z
			contentOffset = contentOffset + (-d * WHEEL_SCROLL_PIXELS)
			updateContentPos()
		end
	end)
end

-- TAB register
local function registerTab(name, onOpen)
	local btn = createTabButton(name)
	tabsRegistry[name] = {Button = btn, onOpen = onOpen}
	btn.MouseButton1Click:Connect(function() setActiveTab(name) end)
end

-- createTabButton / setActiveTab must be available for registerTab; define them now:
function createTabButton(name)
	local btn = new("TextButton", {
		Parent = tabsContainer,
		Text = name,
		Font = Enum.Font.GothamSemibold,
		TextSize = 16,
		TextScaled = true,
		TextColor3 = C.text,
		Size = UDim2.new(1, -12, 0, 44),
		BackgroundColor3 = Color3.fromRGB(49,49,56),
		BorderSizePixel = 0,
		AutoButtonColor = false,
		ZIndex = 197
	})
	new("UICorner", {Parent = btn, CornerRadius = UDim.new(0,10)})
	new("UIStroke", {Parent = btn, Color = Color3.fromRGB(60,60,66), Thickness = 1})
	return btn
end

function setActiveTab(name)
	for k,v in pairs(tabsRegistry) do
		local b = v.Button
		if k == name then
			b.BackgroundColor3 = C.purple
			b.TextColor3 = Color3.fromRGB(245,245,245)
		else
			b.BackgroundColor3 = Color3.fromRGB(49,49,56)
			b.TextColor3 = C.text
		end
	end
	if tabsRegistry[name] and tabsRegistry[name].onOpen then tabsRegistry[name].onOpen() end
	RunService.Heartbeat:Wait()
	updateContentPos()
end

-- ===== Toggle ESP brainrots =====
-- Improved Brainrot finder (LocalScript)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer") and Players.LocalPlayer -- safe access
LocalPlayer = LocalPlayer or Players:WaitForChild("LocalPlayer") -- fallback (shouldn't block normally)
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Config
local TAG_NAME = "Generation"           -- nombre que buscas en los descendants
local THROTTLE_SECONDS = 0.20          -- cada cuánto actualizamos la búsqueda (segundos)
local BILLBOARD_SIZE = UDim2.new(0, 240, 0, 44)
local BILLBOARD_OFFSET = Vector3.new(0, 3.5, 0)
local HIGHLIGHT_OUTLINE_COLOR = Color3.fromRGB(255, 0, 0)
local BILLBOARD_PREFIX = "⭐ Best Brainrot: "

-- Estado
local brainrotEnabled = false
local lastUpdateTime = 0
local dirty = false

-- Mappings para actualizaciones eficientes
local descValues = {}       -- [instance] = {num = number, text = string, parentPart = BasePart}
local descConns = {}        -- [instance] = connection
local trackedDesc = {}      -- set de descendants que estamos observando

-- Objetos visuales
local currentHighlight
local currentBillboard
local currentTextLabel

-- Helpers -------------------------------------------------------------------
local function safeDestroy(inst)
    if inst and inst.Destroy then
        pcall(function() inst:Destroy() end)
    end
end

-- Normaliza y convierte textos como "2.5k", "1,200", "3M", "1.2 B" -> número
local function parseMoney(text)
    if not text then return 0 end
    text = tostring(text):upper():gsub("%s+", "") -- eliminar espacios
    -- extraer la parte numérica (acepta comas y puntos)
    local numStr = text:match("[%d%.,]+")
    if not numStr then return 0 end
    -- Unificar comas/puntos: si contiene ambas, asumimos que las comas son separadores de miles
    if numStr:find(",") and numStr:find("%.") then
        numStr = numStr:gsub(",", "")
    else
        -- si sólo contiene comas (p.ej "1,200") reemplazar por punto para tonumber
        if numStr:find(",") and not numStr:find("%.") then
            numStr = numStr:gsub(",", ".")
        end
    end
    local num = tonumber(numStr) or 0

    -- multiplicadores comunes
    if text:find("T") then
        num = num * 1e12
    elseif text:find("B") then
        num = num * 1e9
    elseif text:find("M") then
        num = num * 1e6
    elseif text:find("K") then
        num = num * 1e3
    end
    return num
end

local function findParentBasePart(instance)
    local p = instance.Parent
    while p do
        if p:IsA("BasePart") then return p end
        p = p.Parent
    end
    return nil
end

-- Extrae texto desde distintos tipos de instances (StringValue, TextLabel, SurfaceGui->TextLabel, etc.)
local function extractTextFromInstance(inst)
    if not inst then return nil end
    local class = inst.ClassName
    if class == "StringValue" or class == "IntValue" or class == "NumberValue" then
        return tostring(inst.Value)
    elseif class == "TextLabel" or class == "TextBox" then
        return tostring(inst.Text)
    elseif class == "SurfaceGui" or class == "BillboardGui" or class == "ScreenGui" then
        -- buscar TextLabel/TextBox hijos (primer nivel y recursivo breve)
        for _, child in ipairs(inst:GetDescendants()) do
            if child.ClassName == "TextLabel" or child.ClassName == "TextBox" then
                return tostring(child.Text)
            end
        end
    end
    return nil
end

-- Actualiza la entrada descValues para un descendant dado
local function updateDescEntry(desc)
    if not desc or not desc.Parent then return end
    local text = extractTextFromInstance(desc)
    if not text or text == "" then
        -- eliminar si existía antes
        if descValues[desc] then
            descValues[desc] = nil
            dirty = true
        end
        return
    end
    local num = parseMoney(text)
    if num <= 0 then
        if descValues[desc] then
            descValues[desc] = nil
            dirty = true
        end
        return
    end
    local parentPart = findParentBasePart(desc)
    if not parentPart then
        -- si no pertenece a un BasePart, ignorar
        if descValues[desc] then
            descValues[desc] = nil
            dirty = true
        end
        return
    end
    local old = descValues[desc]
    if old and old.num == num and old.text == text and old.parentPart == parentPart then
        -- sin cambios
        return
    end
    descValues[desc] = { num = num, text = text, parentPart = parentPart }
    dirty = true
end

-- Conexiones a cambios de propiedad para mantener actualizado descValues
local function watchDesc(desc)
    if not desc or trackedDesc[desc] then return end
    trackedDesc[desc] = true

    local function connectAndListen()
        if desc.ClassName == "StringValue" or desc.ClassName == "IntValue" or desc.ClassName == "NumberValue" then
            descConns[desc] = desc:GetPropertyChangedSignal("Value"):Connect(function()
                updateDescEntry(desc)
            end)
        elseif desc.ClassName == "TextLabel" or desc.ClassName == "TextBox" then
            descConns[desc] = desc:GetPropertyChangedSignal("Text"):Connect(function()
                updateDescEntry(desc)
            end)
        elseif desc.ClassName == "SurfaceGui" or desc.ClassName == "BillboardGui" then
            -- vigilar cambios en descendants (textlabels) de este gui
            descConns[desc] = desc.DescendantAdded:Connect(function(child)
                if child.ClassName == "TextLabel" or child.ClassName == "TextBox" then
                    updateDescEntry(child)
                    -- también watchear el child directamente
                    watchDesc(child)
                end
            end)
            -- inicialmente revisar sus hijos
            for _, child in ipairs(desc:GetDescendants()) do
                if child.ClassName == "TextLabel" or child.ClassName == "TextBox" then
                    watchDesc(child)
                    updateDescEntry(child)
                end
            end
        else
            -- no es interés directo, pero puede contener hijos con TextLabel (ej: Folder)
            -- revisamos sus hijos recursivamente hasta encontrar TextLabel/Value nodes.
            for _, child in ipairs(desc:GetDescendants()) do
                if (child.ClassName == "TextLabel" or child.ClassName == "TextBox"
                    or child.ClassName == "StringValue" or child.ClassName == "IntValue" or child.ClassName == "NumberValue") then
                    watchDesc(child)
                    updateDescEntry(child)
                end
            end
        end
        -- actualizar inmediatamente
        updateDescEntry(desc)
    end

    -- Proteger por si el descendant desaparece en el proceso
    pcall(connectAndListen)
end

local function unwatchDesc(desc)
    if not desc then return end
    trackedDesc[desc] = nil
    if descConns[desc] then
        pcall(function() descConns[desc]:Disconnect() end)
        descConns[desc] = nil
    end
    if descValues[desc] then
        descValues[desc] = nil
        dirty = true
    end
end

-- Reconstruir observación inicial para todo workspace (solo al iniciar)
local function initialScanWorkspace()
    for _, inst in ipairs(Workspace:GetDescendants()) do
        if inst.Name == TAG_NAME then
            watchDesc(inst)
            updateDescEntry(inst)
        else
            -- también si es SurfaceGui/TextLabel/etc contenido dentro de algo llamado Generation
            -- (por si el objeto "Generation" contiene un SurfaceGui)
            local name = inst.Name
            if name == TAG_NAME then
                watchDesc(inst)
                updateDescEntry(inst)
            end
        end
    end
    dirty = true
end

-- Monitoreo de nuevas adiciones/remociones en workspace para objetos con nombre TAG_NAME
local workspaceAddedConn
local workspaceRemovingConn

workspaceAddedConn = Workspace.DescendantAdded:Connect(function(desc)
    if not desc then return end
    if desc.Name == TAG_NAME then
        watchDesc(desc)
        updateDescEntry(desc)
    else
        -- si es un TextLabel, StringValue, etc. en una estructura que puede pertenecer a Generation
        -- revisa su ascendencia hasta ver si está dentro de algo llamado TAG_NAME
        local p = desc.Parent
        while p do
            if p.Name == TAG_NAME then
                -- encontramos que este descendant pertenece a un Generation
                watchDesc(desc)
                updateDescEntry(desc)
                break
            end
            p = p.Parent
        end
    end
end)

workspaceRemovingConn = Workspace.DescendantRemoving:Connect(function(desc)
    if not desc then return end
    -- si el descriptor eliminado estaba trackeado, limpiamos
    unwatchDesc(desc)
end)

-- Visuals -------------------------------------------------------------------
local function ensureHighlight(part)
    if not part then return end
    if not currentHighlight then
        currentHighlight = Instance.new("Highlight")
        currentHighlight.FillTransparency = 1
        currentHighlight.OutlineTransparency = 0
        currentHighlight.OutlineColor = HIGHLIGHT_OUTLINE_COLOR
        currentHighlight.Parent = PlayerGui -- parent doesn't matter much; adornee is the part
    end
    currentHighlight.Adornee = part
end

local function ensureBillboard(part, text)
    if not part then return end
    if not currentBillboard then
        currentBillboard = Instance.new("BillboardGui")
        currentBillboard.Size = BILLBOARD_SIZE
        currentBillboard.StudsOffset = BILLBOARD_OFFSET
        currentBillboard.AlwaysOnTop = true
        currentBillboard.Parent = PlayerGui

        currentTextLabel = Instance.new("TextLabel")
        currentTextLabel.Size = UDim2.new(1, 0, 1, 0)
        currentTextLabel.BackgroundTransparency = 1
        currentTextLabel.TextScaled = true
        currentTextLabel.Font = Enum.Font.GothamBold
        currentTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        currentTextLabel.TextStrokeTransparency = 0.2
        currentTextLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        currentTextLabel.Parent = currentBillboard
    end
    currentBillboard.Adornee = part
    currentTextLabel.Text = BILLBOARD_PREFIX .. tostring(text)
end

local function clearVisuals()
    safeDestroy(currentHighlight)
    safeDestroy(currentBillboard)
    currentHighlight, currentBillboard, currentTextLabel = nil, nil, nil
end

-- Calcula el mejor spawn desde descValues (llamado por throttled loop)
local function computeAndShowBest()
    local bestNum = -math.huge
    local bestText = nil
    local bestPart = nil
    for desc, info in pairs(descValues) do
        if info and info.num and info.parentPart and info.parentPart:IsDescendantOf(Workspace) then
            if info.num > bestNum then
                bestNum = info.num
                bestText = info.text
                bestPart = info.parentPart
            end
        end
    end

    if bestPart and bestText then
        ensureHighlight(bestPart)
        ensureBillboard(bestPart, bestText)
    else
        clearVisuals()
    end
end

-- Core loop: throttle updates
local heartbeatConn
heartbeatConn = RunService.Heartbeat:Connect(function(dt)
    if not brainrotEnabled then return end
    lastUpdateTime = lastUpdateTime + dt
    if dirty and lastUpdateTime >= THROTTLE_SECONDS then
        lastUpdateTime = 0
        dirty = false
        -- protege por si compute falla
        local ok, err = pcall(computeAndShowBest)
        if not ok then
            warn("[Brainrot] Error computing best spawn:", err)
        end
    end
end)

-- Public API ---------------------------------------------------------------
local function toggleBrainrot(value)
    if typeof(value) ~= "boolean" then
        warn("[Brainrot] Valor inválido (esperado booleano).")
        return
    end
    if brainrotEnabled == value then
        return -- sin cambios
    end
    brainrotEnabled = value
    if brainrotEnabled then
        -- aseguramos escaneo inicial (pero no re-scan completo cada vez)
        dirty = true
        lastUpdateTime = THROTTLE_SECONDS -- forzar update inmediato en el siguiente Heartbeat
    else
        clearVisuals()
    end
end

local function isBrainrotEnabled()
    return brainrotEnabled
end

-- Inicialización
initialScanWorkspace()

-- Exponer funciones (si quieres llamarlas desde otro script local)
local Brainrot = {
    Toggle = toggleBrainrot,
    Enabled = isBrainrotEnabled,
    Clear = clearVisuals,
}

-- Ejemplo: si quieres activar por defecto comenta/descomenta la siguiente línea:
-- Brainrot.Toggle(true)

-- Retornar tabla para uso si el script es requerible (module style no aplicaría en LocalScript,
-- pero dejamos la variable en _G para depuración si se desea)
_G.Brainrot = Brainrot

-- Limpieza cuando el jugador se va (opcional)
Players.PlayerRemoving:Connect(function(plr)
    if plr == LocalPlayer then
        -- desconectar todas las conexiones que creamos
        if workspaceAddedConn then pcall(function() workspaceAddedConn:Disconnect() end) end
        if workspaceRemovingConn then pcall(function() workspaceRemovingConn:Disconnect() end) end
        if heartbeatConn then pcall(function() heartbeatConn:Disconnect() end) end
        for d, conn in pairs(descConns) do
            pcall(function() conn:Disconnect() end)
        end
        descConns = {}
        descValues = {}
        trackedDesc = {}
        clearVisuals()
    end
end)

-- ===== Capa Laser =====
local laserGuiCreated = false
local laserScreenGui = nil
local laserFrameRef = nil

local function createLaserGui()
    if laserGuiCreated then return end
    laserGuiCreated = true

    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LocalPlayer = player
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

    local RFCoinsShopServiceRequestBuy
    local REUseItem
    pcall(function()
        RFCoinsShopServiceRequestBuy = ReplicatedStorage.Packages.Net["RF/CoinsShopService/RequestBuy"]
        REUseItem = ReplicatedStorage.Packages.Net["RE/UseItem"]
    end)

    for _, existingGui in pairs(player.PlayerGui:GetChildren()) do
        if existingGui:IsA("ScreenGui") and existingGui.Name == "WeroScriptGUI" then
            existingGui:Destroy()
        end
    end

    laserScreenGui = Instance.new("ScreenGui")
    laserScreenGui.Name = "WeroScriptGUI"
    laserScreenGui.ResetOnSpawn = false
    laserScreenGui.Parent = player:WaitForChild("PlayerGui")
    laserScreenGui.Enabled = true

    local frameL = Instance.new("Frame")
    frameL.Size = UDim2.new(0, 250, 0, 150)
    frameL.Position = UDim2.new(0.4, 0, 0.3, 0)
    frameL.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    frameL.BorderSizePixel = 0
    frameL.Active = true
    frameL.Draggable = true
    frameL.Parent = laserScreenGui
    laserFrameRef = frameL

    local uicorner = Instance.new("UICorner", frameL)
    uicorner.CornerRadius = UDim.new(0, 10)

    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 40)
    title.BackgroundTransparency = 1
    title.Text = "⚡ WeroScript GUI"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 20
    title.Parent = frameL

    local buyButton = Instance.new("TextButton")
    buyButton.Size = UDim2.new(1, -20, 0, 40)
    buyButton.Position = UDim2.new(0, 10, 0, 50)
    buyButton.BackgroundColor3 = Color3.fromRGB(0, 102, 204)
    buyButton.Text = "🛒 Buy Laser Cape"
    buyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    buyButton.Font = Enum.Font.GothamBold
    buyButton.TextSize = 16
    buyButton.Parent = frameL

    local buyCorner = Instance.new("UICorner", buyButton)
    buyCorner.CornerRadius = UDim.new(0, 8)

    local autoButton = Instance.new("TextButton")
    autoButton.Size = UDim2.new(1, -20, 0, 40)
    autoButton.Position = UDim2.new(0, 10, 0, 100)
    autoButton.BackgroundColor3 = Color3.fromRGB(34, 139, 34)
    autoButton.Text = "✔ Auto Laser: OFF"
    autoButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    autoButton.Font = Enum.Font.GothamBold
    autoButton.TextSize = 16
    autoButton.Parent = frameL

    local autoCorner = Instance.new("UICorner", autoButton)
    autoCorner.CornerRadius = UDim.new(0, 8)

    local autoLaserEnabled = false
    local circlePart = nil
    local equipLoop = nil
    local detectConn = nil
    local alreadyBought = false

    buyButton.MouseButton1Click:Connect(function()
        if not alreadyBought then
            if RFCoinsShopServiceRequestBuy then
                pcall(function()
                    RFCoinsShopServiceRequestBuy:InvokeServer("Laser Cape")
                end)
            end
            alreadyBought = true
            buyButton.Text = "✔ Laser Cape Bought"
            buyButton.BackgroundColor3 = Color3.fromRGB(0, 180, 255)
        end
    end)

    autoButton.MouseButton1Click:Connect(function()
        autoLaserEnabled = not autoLaserEnabled
        if autoLaserEnabled then
            autoButton.Text = "✔ Auto Laser: ON"
            autoButton.BackgroundColor3 = Color3.fromRGB(34, 200, 34)

            Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

            if not circlePart then
                circlePart = Instance.new("Part")
                circlePart.Shape = Enum.PartType.Cylinder
                circlePart.Anchored = true
                circlePart.CanCollide = false
                circlePart.Size = Vector3.new(120, 1, 120)
                circlePart.Color = Color3.fromRGB(0, 255, 0)
                circlePart.Transparency = 0.5
                circlePart.Material = Enum.Material.Neon
                circlePart.Parent = workspace
            end

            if not equipLoop then
                equipLoop = RunService.Heartbeat:Connect(function()
                    pcall(function()
                        local backpack = LocalPlayer:FindFirstChild("Backpack")
                        local tool = backpack and backpack:FindFirstChild("Laser Cape") or Character:FindFirstChild("Laser Cape")
                        if tool and tool.Parent ~= Character then
                            tool.Parent = Character
                        end
                    end)
                end)
            end

            if not detectConn then
                detectConn = RunService.RenderStepped:Connect(function()
                    if circlePart and autoLaserEnabled then
                        local char = LocalPlayer.Character
                        if not char or not char:FindFirstChild("HumanoidRootPart") then return end
                        local hrp = char.HumanoidRootPart
                        circlePart.CFrame = hrp.CFrame * CFrame.new(0, -2.5, 0) * CFrame.Angles(math.rad(90), 0, 0)

                        for _, plr in ipairs(Players:GetPlayers()) do
                            if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                                local targetHRP = plr.Character.HumanoidRootPart
                                local dist = (targetHRP.Position - hrp.Position).Magnitude
                                if dist <= 75 then
                                    if REUseItem then
                                        pcall(function()
                                            REUseItem:FireServer(Vector3.new(-345, -7, 3), targetHRP)
                                        end)
                                    end
                                end
                            end
                        end
                    end
                end)
            end

        else
            autoButton.Text = "✔ Auto Laser: OFF"
            autoButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
            if circlePart then
                circlePart:Destroy()
                circlePart = nil
            end
            if equipLoop then
                equipLoop:Disconnect()
                equipLoop = nil
            end
            if detectConn then
                detectConn:Disconnect()
                detectConn = nil
            end
        end
    end)
end

function toggleLaserGui(value)
    if typeof(value) ~= "boolean" then
        warn("[LaserGUI] Valor inválido, se esperaba booleano.")
        return
    end

    if value then
        if not laserGuiCreated then
            createLaserGui()
        else
            if laserScreenGui then
                laserScreenGui.Enabled = true
            end
        end
    else
        if laserScreenGui then
            laserScreenGui.Enabled = false
        end
    end
end

-- ===== Float Quantum =====
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local workspace = workspace

local LocalPlayer = Players.LocalPlayer

local TOOL_NAME = "Quantum Cloner"
local CLONE_SEARCH_PATTERN = "^(%d+)_Clone$"
local UPDATE_INTERVAL = 0.05
local LOOK_UP_THRESHOLD = 0.4
local LOOK_DOWN_THRESHOLD = -0.4
local FLY_POWER = 60
local MIN_MOVE_MAG = 0.1

-- Estado
local active = false
local usingClone = false
local currentCloneModel = nil

local function getCamera()
    if workspace.CurrentCamera then return workspace.CurrentCamera end
    local sign = workspace:GetPropertyChangedSignal("CurrentCamera")
    local cam = workspace.CurrentCamera
    if cam then return cam end
    -- esperar hasta que aparezca
    local t0 = tick()
    while not workspace.CurrentCamera and tick() - t0 < 5 do
        sign:Wait()
    end
    return workspace.CurrentCamera
end

local Camera = getCamera()

local function getUseItemRemote()
    -- intento estructurado
    local ok, result = pcall(function()
        local pk = ReplicatedStorage:FindFirstChild("Packages")
        if pk then
            local net = pk:FindFirstChild("Net")
            if net then
                return net:FindFirstChild("RE/UseItem")
            end
        end
    end)
    if ok and result and result:IsA("RemoteEvent") then return result end

    local found = ReplicatedStorage:FindFirstChild("RE/UseItem", true)
    if found and found:IsA("RemoteEvent") then return found end
    return nil
end

local USE_ITEM_REMOTE = getUseItemRemote()

-- Buscar el clon con tu userid
local function findMyClone()
    local uidStr = tostring(LocalPlayer.UserId)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and type(obj.Name) == "string" then
            local uid = string.match(obj.Name, CLONE_SEARCH_PATTERN)
            if uid and tostring(tonumber(uid)) == uidStr then
                return obj
            end
        end
    end
    return nil
end

local function positionCloneUnderPlayer(cloneModel)
    if not cloneModel then return false end
    local cloneHRP = cloneModel:FindFirstChild("HumanoidRootPart") or cloneModel:FindFirstChildWhichIsA("BasePart")
    if not cloneHRP then return false end

    local char = LocalPlayer.Character
    if not char then return false end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    local look = hrp.CFrame.LookVector
    local backOffset = look * -1 * 1.2
    local desiredPos = hrp.Position + Vector3.new(0, -3.5, 0) + backOffset
    local orient = CFrame.new(desiredPos, desiredPos + hrp.CFrame.LookVector)
    local lieCFrame = orient * CFrame.Angles(math.rad(90), 0, 0)

    pcall(function()
        cloneHRP.Anchored = true
        cloneHRP.CFrame = lieCFrame
    end)
    return true
end

local function flightLoop()
    -- actualizar Camera cada vez por si cambia
    Camera = getCamera()
    while active and usingClone and currentCloneModel and currentCloneModel.Parent do
        local char = LocalPlayer.Character
        if char then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local hum = char:FindFirstChildWhichIsA("Humanoid")
            if hrp and hum then
                -- posicionar clon
                pcall(function() positionCloneUnderPlayer(currentCloneModel) end)

                local moveMag = hum.MoveDirection and hum.MoveDirection.Magnitude or 0
                local camLookY = (Camera and Camera.CFrame and Camera.CFrame.LookVector.Y) or hrp.CFrame.LookVector.Y
                if moveMag > MIN_MOVE_MAG then
                    if camLookY > LOOK_UP_THRESHOLD then
                        -- subir
                        hrp.Velocity = Vector3.new(hrp.Velocity.X, FLY_POWER, hrp.Velocity.Z)
                    elseif camLookY < LOOK_DOWN_THRESHOLD then
                        -- bajar
                        hrp.Velocity = Vector3.new(hrp.Velocity.X, -FLY_POWER, hrp.Velocity.Z)
                    end
                end
            end
        end
        task.wait(UPDATE_INTERVAL)
    end
end

local function startUsingClone(cloneModel)
    if not cloneModel then return false end
    currentCloneModel = cloneModel
    usingClone = true
    -- asegurar que esté posicionado al inicio
    positionCloneUnderPlayer(cloneModel)
    -- iniciar loop de vuelo en background
    task.spawn(flightLoop)
    return true
end

local function stopUsingClone()
    usingClone = false
    if currentCloneModel and currentCloneModel.Parent then
        local cloneHRP = currentCloneModel:FindFirstChild("HumanoidRootPart") or currentCloneModel:FindFirstChildWhichIsA("BasePart")
        if cloneHRP then
            pcall(function() cloneHRP.Anchored = false end)
        end
    end
    currentCloneModel = nil
end

local function floatV2Button(estado)
    if estado == nil then return end

    if estado and not active then
        active = true

        if LocalPlayer.Character then
            local toolInChar = LocalPlayer.Character:FindFirstChild(TOOL_NAME)
            if toolInChar and USE_ITEM_REMOTE then
                pcall(function()
                    USE_ITEM_REMOTE:FireServer(toolInChar)
                end)
            end
        end

        local attempts, maxAttempts = 0, 60
        local myClone = findMyClone()
        while not myClone and attempts < maxAttempts and active do
            attempts = attempts + 1
            task.wait(0.15)
            myClone = findMyClone()
        end

        if myClone then
            local ok = startUsingClone(myClone)
            if not ok then
                warn("[Float v2] fallo al iniciar clon")
                active = false
            end
        else
            warn("[Float v2] no se encontró " .. tostring(LocalPlayer.UserId) .. "_Clone")
            active = false
        end

    elseif not estado and active then
        -- apagar
        active = false
        stopUsingClone()
    end
end

_G.floatV2Button = floatV2Button

-- ===== Toggle ESP Players =====
-- ESP mejorado: persiste al morir del local player, toggle reversible y actualizado en tiempo real.
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local SCREEN_NAME = "ESP_ScreenGui_Wero"
local ESP_FOLDER_NAME = "ESP_Players"

-- Crear (o recuperar) ScreenGui que persista al respawn
local function getOrCreateScreenGui()
    local sg = PlayerGui:FindFirstChild(SCREEN_NAME)
    if not sg then
        sg = Instance.new("ScreenGui")
        sg.Name = SCREEN_NAME
        sg.ResetOnSpawn = false
        sg.Parent = PlayerGui
    end
    return sg
end

local espScreen = getOrCreateScreenGui()

-- folder para ordenar los BillboardGuis
local espFolder = espScreen:FindFirstChild(ESP_FOLDER_NAME)
if not espFolder then
    espFolder = Instance.new("Folder")
    espFolder.Name = ESP_FOLDER_NAME
    espFolder.Parent = espScreen
end

-- Estado y datos
local espEnabled = false
local espData = {} -- mapa player -> { gui = BillboardGui, parts = {...}, conns = {charConn, humConn, removeConn}, lastHealth = number }

-- util: color segun porcentaje de vida (verde->rojo)
local function healthColorFromPercent(p)
    p = math.clamp(p, 0, 1)
    local r = (1 - p) * 255
    local g = p * 255
    return Color3.fromRGB(math.floor(r), math.floor(g), 40)
end

-- Desconectar conexiones guardadas de un jugador (si existen)
local function disconnectConns(conns)
    if not conns then return end
    if conns.charConn and conns.charConn.Connected then
        pcall(function() conns.charConn:Disconnect() end)
    end
    if conns.humConn and conns.humConn.Connected then
        pcall(function() conns.humConn:Disconnect() end)
    end
    if conns.removeConn and conns.removeConn.Connected then
        pcall(function() conns.removeConn:Disconnect() end)
    end
    if conns.healthChangedConn and conns.healthChangedConn.Connected then
        pcall(function() conns.healthChangedConn:Disconnect() end)
    end
    if conns.diedConn and conns.diedConn.Connected then
        pcall(function() conns.diedConn:Disconnect() end)
    end
end

-- limpiar por completo (solo si lo necesitas manualmente)
local function clearAllESP()
    for p, _ in pairs(espData) do
        local data = espData[p]
        disconnectConns(data.conns)
        if data.gui and data.gui.Parent then
            data.gui:Destroy()
        end
        espData[p] = nil
    end
    for _, obj in ipairs(espFolder:GetChildren()) do
        obj:Destroy()
    end
end

-- Attacha conexiones relacionadas al Humanoid para actualizaciones inmediatas
local function attachHumanoidListeners(plr, humanoid)
    if not plr or not humanoid then return nil end
    local data = espData[plr]
    if not data then return nil end
    local conns = data.conns

    -- HealthChanged -> actualizar barra inmediatamente
    conns.healthChangedConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
        if not data.parts or not data.parts.healthInner then return end
        local maxH = humanoid.MaxHealth > 0 and humanoid.MaxHealth or 100
        local curr = math.clamp(humanoid.Health, 0, maxH)
        local pct = curr / maxH
        data.parts.healthInner.Size = UDim2.new(pct, 0, 1, 0)
        data.parts.healthInner.BackgroundColor3 = healthColorFromPercent(pct)
        if data.parts.pct then
            data.parts.pct.Text = tostring(math.floor(pct * 100)) .. "%"
        end
        data.lastHealth = curr
    end)

    -- Died -> marcar 0% inmediatamente
    conns.diedConn = humanoid.Died:Connect(function()
        if data.parts and data.parts.healthInner then
            data.parts.healthInner.Size = UDim2.new(0, 0, 1, 0)
            data.parts.healthInner.BackgroundColor3 = healthColorFromPercent(0)
            if data.parts.pct then data.parts.pct.Text = "0%" end
        end
        data.lastHealth = 0
    end)

    return true
end

-- Crea (o reutiliza) el BillboardGui + elementos para un jugador
local function createESPGuiForPlayer(plr)
    if not plr or not plr:IsA("Player") then return end

    local data = espData[plr]
    if data and data.gui and data.gui.Parent then
        -- ya existe y está bien
        return
    end

    -- Si existe data pero gui fue destruida por alguna razón, limpiamos conexiones antiguas
    if data == nil then
        data = {
            gui = nil,
            parts = {},
            conns = {},
            lastHealth = nil
        }
        espData[plr] = data
    else
        -- limpiar conns viejas si existen (no destroy GUI aquí)
        disconnectConns(data.conns)
        data.conns = {}
        data.parts = data.parts or {}
    end

    -- crear BillboardGui
    local bill = Instance.new("BillboardGui")
    bill.Name = "ESP_" .. plr.Name
    bill.Adornee = nil
    bill.Size = UDim2.new(0, 220, 0, 56)
    bill.StudsOffset = Vector3.new(0, 2.6, 0)
    bill.AlwaysOnTop = true
    bill.ResetOnSpawn = false -- importante para que no se borre si el jugador respawnea
    bill.MaxDistance = 512
    bill.Parent = espFolder

    -- Fondo
    local bg = Instance.new("Frame")
    bg.Size = UDim2.new(1, 0, 1, 0)
    bg.Position = UDim2.new(0, 0, 0, 0)
    bg.BackgroundTransparency = 0.45
    bg.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
    bg.BorderSizePixel = 0
    bg.Parent = bill
    local bgCorner = Instance.new("UICorner", bg)
    bgCorner.CornerRadius = UDim.new(0, 8)

    -- Nombre
    local nameLbl = Instance.new("TextLabel")
    nameLbl.Size = UDim2.new(0.6, -8, 0, 20)
    nameLbl.Position = UDim2.new(0, 8, 0, 6)
    nameLbl.BackgroundTransparency = 1
    nameLbl.Text = plr.Name
    nameLbl.Font = Enum.Font.GothamBold
    nameLbl.TextSize = 14
    nameLbl.TextColor3 = Color3.fromRGB(230, 230, 230)
    nameLbl.TextXAlignment = Enum.TextXAlignment.Left
    nameLbl.Parent = bill
    nameLbl.ZIndex = 2

    -- Team tag
    local teamTag = Instance.new("Frame")
    teamTag.Size = UDim2.new(0, 16, 0, 16)
    teamTag.Position = UDim2.new(0.62, 0, 0, 8)
    teamTag.BackgroundColor3 = (plr.Team and plr.Team.TeamColor.Color) or Color3.fromRGB(120, 120, 120)
    teamTag.BorderSizePixel = 0
    teamTag.Parent = bill
    Instance.new("UICorner", teamTag).CornerRadius = UDim.new(0, 4)
    teamTag.ZIndex = 2

    -- Distance
    local distLbl = Instance.new("TextLabel")
    distLbl.Size = UDim2.new(0.36, -8, 0, 20)
    distLbl.Position = UDim2.new(0.64, 0, 0, 6)
    distLbl.BackgroundTransparency = 1
    distLbl.Text = ""
    distLbl.Font = Enum.Font.Gotham
    distLbl.TextSize = 12
    distLbl.TextColor3 = Color3.fromRGB(200, 200, 200)
    distLbl.TextXAlignment = Enum.TextXAlignment.Right
    distLbl.Parent = bill
    distLbl.ZIndex = 2

    -- Barra de vida (bg)
    local healthBG = Instance.new("Frame")
    healthBG.Size = UDim2.new(0.9, 0, 0, 10)
    healthBG.Position = UDim2.new(0.05, 0, 0, 30)
    healthBG.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    healthBG.BorderSizePixel = 0
    healthBG.Parent = bill
    Instance.new("UICorner", healthBG).CornerRadius = UDim.new(0, 6)
    healthBG.ZIndex = 2

    local healthInner = Instance.new("Frame")
    healthInner.Size = UDim2.new(1, 0, 1, 0)
    healthInner.Position = UDim2.new(0, 0, 0, 0)
    healthInner.BackgroundColor3 = Color3.fromRGB(34, 200, 34)
    healthInner.BorderSizePixel = 0
    healthInner.Parent = healthBG
    Instance.new("UICorner", healthInner).CornerRadius = UDim.new(0, 6)
    healthInner.ZIndex = 3

    local pctLbl = Instance.new("TextLabel")
    pctLbl.Size = UDim2.new(1, 0, 1, 0)
    pctLbl.Position = UDim2.new(0, 0, 0, 0)
    pctLbl.BackgroundTransparency = 1
    pctLbl.Text = ""
    pctLbl.Font = Enum.Font.Gotham
    pctLbl.TextSize = 10
    pctLbl.TextColor3 = Color3.fromRGB(20,20,20)
    pctLbl.TextXAlignment = Enum.TextXAlignment.Center
    pctLbl.Parent = healthBG
    pctLbl.ZIndex = 4

    -- Save references
    data.gui = bill
    data.parts = {
        name = nameLbl,
        team = teamTag,
        dist = distLbl,
        healthBG = healthBG,
        healthInner = healthInner,
        pct = pctLbl
    }
    data.conns = data.conns or {}
    data.lastHealth = nil

    -- Intentar asignar Adornee si el personaje ya existe
    local function tryAttachToCharacter()
        local char = plr.Character
        if char and char.Parent then
            local hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
            if hrp then
                data.gui.Adornee = hrp
            else
                data.gui.Adornee = nil
            end
        else
            data.gui.Adornee = nil
        end
    end
    tryAttachToCharacter()

    -- CharacterAdded -> reasignar Adornee y reconectar humanoid
    data.conns.charConn = plr.CharacterAdded:Connect(function(char)
        task.wait(0.15)
        tryAttachToCharacter()

        -- reconectar humanoid listeners
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            -- desconectar humConn viejo si existe
            if data.conns.healthChangedConn then
                pcall(function() data.conns.healthChangedConn:Disconnect() end)
                data.conns.healthChangedConn = nil
            end
            if data.conns.diedConn then
                pcall(function() data.conns.diedConn:Disconnect() end)
                data.conns.diedConn = nil
            end
            attachHumanoidListeners(plr, humanoid)
        end
    end)

    -- Si ya hay humanoid al crear, conectar listeners
    local curChar = plr.Character
    local humanoid = curChar and curChar:FindFirstChildOfClass("Humanoid")
    if humanoid then
        attachHumanoidListeners(plr, humanoid)
    end

    -- Cuando el jugador se vaya (player object eliminado del árbol), limpiar
    data.conns.removeConn = plr.AncestryChanged:Connect(function(_, parent)
        if not parent then
            -- jugador eliminado completamente
            disconnectConns(data.conns)
            if data.gui and data.gui.Parent then data.gui:Destroy() end
            espData[plr] = nil
            if data.conns.removeConn and data.conns.removeConn.Connected then
                pcall(function() data.conns.removeConn:Disconnect() end)
            end
        end
    end)

    -- Respetar el estado actual (habilitado/deshabilitado)
    if data.gui then
        data.gui.Enabled = espEnabled
    end
end

-- Remove/limpia solo cuando el jugador sale del juego
local function removeESPForPlayer(plr)
    if not espData[plr] then return end
    local data = espData[plr]
    disconnectConns(data.conns)
    if data.gui and data.gui.Parent then
        data.gui:Destroy()
    end
    espData[plr] = nil
end

-- --- Loop de actualización (throttled) ---
local UPDATE_INTERVAL = 0.08
local accumulator = 0

RunService.Heartbeat:Connect(function(dt)
    if not espEnabled then return end
    accumulator = accumulator + dt
    if accumulator < UPDATE_INTERVAL then return end
    accumulator = 0

    local camera = workspace.CurrentCamera
    local localHRP = LocalPlayer.Character and (LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character:FindFirstChild("Torso") or LocalPlayer.Character:FindFirstChild("UpperTorso"))
    local localPos = localHRP and localHRP.Position or (camera and camera.CFrame.Position) or Vector3.new()

    for plr, data in pairs(espData) do
        if plr == LocalPlayer then
            -- por defecto no mostramos el ESP de uno mismo; si quisieras mostrarlo, quita este continue
            if data.gui and data.gui.Parent then
                data.gui.Parent = espFolder
            end
            continue
        end

        if not data or not data.gui or not data.gui.Parent then
            createESPGuiForPlayer(plr)
            data = espData[plr]
            if not data then continue end
        end

        local gui = data.gui
        local parts = data.parts

        -- actualizar team color y nombre
        local teamColor = (plr.Team and plr.Team.TeamColor.Color) or Color3.fromRGB(120, 120, 120)
        if parts.team and parts.team.BackgroundColor3 ~= teamColor then
            parts.team.BackgroundColor3 = teamColor
        end

        if parts.name then
            local display = (plr.DisplayName and plr.DisplayName ~= "") and plr.DisplayName or plr.Name
            parts.name.Text = display
        end

        -- Adornee, distancia y vida
        local char = plr.Character
        local hrp = char and (char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso"))
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")

        if hrp then
            if gui.Adornee ~= hrp then gui.Adornee = hrp end
        else
            gui.Adornee = nil
        end

        if hrp and parts.dist then
            local dist = math.floor((hrp.Position - localPos).Magnitude)
            parts.dist.Text = tostring(dist) .. "m"
        elseif parts.dist then
            parts.dist.Text = ""
        end

        if humanoid and parts.healthInner and parts.pct then
            local maxH = humanoid.MaxHealth > 0 and humanoid.MaxHealth or 100
            local curr = math.clamp(humanoid.Health, 0, maxH)
            local pct = curr / maxH
            parts.healthInner.Size = UDim2.new(pct, 0, 1, 0)
            parts.healthInner.BackgroundColor3 = healthColorFromPercent(pct)
            parts.pct.Text = tostring(math.floor(pct * 100)) .. "%"
            data.lastHealth = curr
        else
            -- sin humanoid -> 0%
            if parts.healthInner then
                parts.healthInner.Size = UDim2.new(0, 0, 1, 0)
                parts.healthInner.BackgroundColor3 = healthColorFromPercent(0)
            end
            if parts.pct then parts.pct.Text = "" end
        end
    end
end)

-- Players events
Players.PlayerAdded:Connect(function(plr)
    -- siempre crear la estructura (pero respetar espEnabled para mostrar u ocultar)
    createESPGuiForPlayer(plr)
end)

Players.PlayerRemoving:Connect(function(plr)
    pcall(function() removeESPForPlayer(plr) end)
end)

-- API pública para togglear ESP; mantiene datos cuando se apaga para poder reactivar
function toggleEspPlayers(value)
    if type(value) ~= "boolean" then
        warn("[ESP] Valor inválido, se esperaba booleano.")
        return
    end

    espEnabled = value

    if espEnabled then
        -- asegurarse de que la GUI contenedora existe
        espScreen = getOrCreateScreenGui()
        if not espFolder.Parent then
            espFolder.Parent = espScreen
        end

        -- crear/activar para todos los jugadores actuales ( excepto local )
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                createESPGuiForPlayer(plr)
            end
        end

        -- habilitar visualmente todas las GUIs existentes
        for _, data in pairs(espData) do
            if data.gui then
                data.gui.Enabled = true
            end
        end
    else
        -- Desactivar solo visualmente (no destruir). Así se restaura al volver a activar.
        for _, data in pairs(espData) do
            if data.gui then
                data.gui.Enabled = false
            end
        end
    end
end
-- ===== Toggle ESP Timer =====
getgenv().ESP_Global = getgenv().ESP_Global or {}
getgenv().ESP_Global.espBases = getgenv().ESP_Global.espBases or {}
local espBases = getgenv().ESP_Global.espBases

local espBasesEnabled = false

local function findPrimaryPart(model)
    if not model then return nil end
    if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then return model.PrimaryPart end
    return model:FindFirstChildWhichIsA("BasePart", true)
end

local function createESPBaseFor(model)
    if not model then return end
    if type(espBases) ~= "table" then return end
    if espBases[model] then return end

    local basePart = findPrimaryPart(model)
    if not basePart then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "WeroScriptESP_Board"
    billboard.Size = UDim2.new(0, 200, 0, 40)
    billboard.StudsOffset = Vector3.new(0, 3.2, 0)
    billboard.AlwaysOnTop = true

    -- Parenting: BillboardGui puede ir como hijo de una BasePart en muchos contextos
    -- Si da problema, puedes parentearlo a workspace.CurrentCamera o a PlayerGui (según tu caso)
    billboard.Parent = basePart

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -8, 1, 0)
    label.Position = UDim2.new(0, 4, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = model.Name
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.GothamBold
    label.TextStrokeTransparency = 0
    label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    label.TextScaled = true
    label.Parent = billboard

    local remTime = model:FindFirstChild("RemainingTime", true)
    if remTime and remTime:IsA("TextLabel") then
        label.Text = remTime.Text
        remTime:GetPropertyChangedSignal("Text"):Connect(function()
            if label and label.Parent then
                label.Text = remTime.Text
            end
        end)
    end

    local ok, box = pcall(function()
        local s = Instance.new("SelectionBox")
        s.Name = "WeroScriptESP_Box"
        s.Adornee = basePart
        s.LineThickness = 0.02
        s.Color3 = Color3.fromRGB(255, 255, 255)
        s.SurfaceTransparency = 1
        s.Parent = basePart
        return s
    end)

    if not ok or not box then
        local hl = Instance.new("Highlight")
        hl.Name = "WeroScriptESP_Box"
        hl.FillTransparency = 1
        hl.OutlineTransparency = 0
        hl.OutlineColor3 = Color3.fromRGB(255, 255, 255)
        hl.Parent = model
        espBases[model] = {billboard = billboard, box = hl}
    else
        espBases[model] = {billboard = billboard, box = box}
    end
end

local function removeBaseESP(model)
    if type(espBases) ~= "table" then return end
    local t = espBases[model]
    if not t then return end
    if t.billboard and t.billboard.Parent then pcall(function() t.billboard:Destroy() end) end
    if t.box and t.box.Parent then pcall(function() t.box:Destroy() end) end
    espBases[model] = nil
end

local function clearAllBaseESP()
    if type(espBases) ~= "table" then return end
    -- defensivo: copiamos las keys porque removeBaseESP modifica la tabla
    local keys = {}
    for model,_ in pairs(espBases) do table.insert(keys, model) end
    for _, model in ipairs(keys) do removeBaseESP(model) end
end

-- Esperar Plots de forma segura
local plots = workspace:FindFirstChild("Plots") or workspace:WaitForChild("Plots", 5) -- espera hasta 5s
if plots then
    plots.ChildAdded:Connect(function(child)
        if espBasesEnabled and child:IsA("Model") then
            task.wait(0.3)
            createESPBaseFor(child)
        end
    end)

    plots.ChildRemoved:Connect(function(child)
        if type(espBases) == "table" and espBases[child] then
            removeBaseESP(child)
        end
    end)
else
    warn("WeroScript: workspace.Plots no encontrado en 5s; no se crearán ESP de bases.")
end

local function espBasesToggle(state)
    espBasesEnabled = state
    clearAllBaseESP()
    if state and plots then
        for _, base in pairs(plots:GetChildren()) do
            if base:IsA("Model") then
                createESPBaseFor(base)
            end
        end
    end
end

-- ===== Falling Fly =====
local caerLentoActivo = false

-- Funcion que aplica la caida lenta
local function activarCaidaLenta()
    local player = game.Players.LocalPlayer
    local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")

    if not humanoid then return end

    -- Reducimos la gravedad solo para el cliente
    game:GetService("RunService").Heartbeat:Connect(function()
        if caerLentoActivo and humanoid and humanoid.RootPart then
            -- Forzar velocidad de caída lenta
            humanoid.RootPart.Velocity = Vector3.new(
                humanoid.RootPart.Velocity.X,
                math.clamp(humanoid.RootPart.Velocity.Y, -0.001, 0.001), -- entre -5 y 5 para que caiga despacio
                humanoid.RootPart.Velocity.Z
            )
        end
    end)
end

-- Funcion toggle para usar con tu boton
local function toggleCaidaLenta()
    caerLentoActivo = not caerLentoActivo
    if caerLentoActivo then
        print("✅ Caída lenta ACTIVADA")
    else
        print("❌ Caída lenta DESACTIVADA")
    end
end

-- Inicializamos la función de caida lenta
activarCaidaLenta()

-- ===== Control Players GUI=====
local controlGuiCreated = false
local controlScreenGui = nil
local controlFrameRef = nil
local controlTarget = nil
local controlling = false
local originalChar = nil
local originalCamSubject = nil

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local REUseItem
pcall(function()
    REUseItem = ReplicatedStorage.Packages.Net["RE/UseItem"]
end)

-- === D-PAD PARA CELULAR ===
local function createMobileControls(parentFrame, setDir, setJump)
    local dpad = Instance.new("Frame")
    dpad.Size = UDim2.new(0, 150, 0, 150)
    dpad.Position = UDim2.new(1, -160, 1, -160)
    dpad.BackgroundTransparency = 1
    dpad.Parent = parentFrame

    local function makeBtn(text, pos, callback)
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(0, 40, 0, 40)
        btn.Position = pos
        btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        btn.Text = text
        btn.TextColor3 = Color3.new(1,1,1)
        btn.Font = Enum.Font.GothamBold
        btn.TextSize = 18
        btn.Parent = dpad
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0,8)

        btn.MouseButton1Down:Connect(function() callback(true) end)
        btn.MouseButton1Up:Connect(function() callback(false) end)
        btn.TouchLongPress:Connect(function(_, state) 
            if state == Enum.UserInputState.Begin then callback(true) end
            if state == Enum.UserInputState.End then callback(false) end
        end)
    end

    makeBtn("↑", UDim2.new(0, 55, 0, 0), function(pressed) 
        if pressed then setDir(Vector3.new(0,0,1)) else setDir(Vector3.zero) end
    end)
    makeBtn("↓", UDim2.new(0, 55, 0, 110), function(pressed) 
        if pressed then setDir(Vector3.new(0,0,-1)) else setDir(Vector3.zero) end
    end)
    makeBtn("←", UDim2.new(0, 0, 0, 55), function(pressed) 
        if pressed then setDir(Vector3.new(-1,0,0)) else setDir(Vector3.zero) end
    end)
    makeBtn("→", UDim2.new(0, 110, 0, 55), function(pressed) 
        if pressed then setDir(Vector3.new(1,0,0)) else setDir(Vector3.zero) end
    end)
    makeBtn("⤴", UDim2.new(0, 200, 0, 55), function(pressed) 
        setJump(pressed)
    end)
end

-- Función para crear GUI
local function createControlGui()
    if controlGuiCreated then return end
    controlGuiCreated = true

    for _, existingGui in pairs(LocalPlayer.PlayerGui:GetChildren()) do
        if existingGui:IsA("ScreenGui") and existingGui.Name == "WeroScriptControlGUI" then
            existingGui:Destroy()
        end
    end

    controlScreenGui = Instance.new("ScreenGui")
    controlScreenGui.Name = "WeroScriptControlGUI"
    controlScreenGui.ResetOnSpawn = false
    controlScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    controlScreenGui.Enabled = true

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 250, 0, 150)
    frame.Position = UDim2.new(0.4, 0, 0.3, 0)
    frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    frame.BorderSizePixel = 0
    frame.Active = true
    frame.Draggable = true
    frame.Parent = controlScreenGui
    controlFrameRef = frame
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)

    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 40)
    title.BackgroundTransparency = 1
    title.Text = "🎮 Control Players"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 20
    title.Parent = frame

    local shootButton = Instance.new("TextButton")
    shootButton.Size = UDim2.new(1, -20, 0, 40)
    shootButton.Position = UDim2.new(0, 10, 0, 50)
    shootButton.BackgroundColor3 = Color3.fromRGB(0, 102, 204)
    shootButton.Text = "🔫 Shoot Nearest Player"
    shootButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    shootButton.Font = Enum.Font.GothamBold
    shootButton.TextSize = 16
    shootButton.Parent = frame
    Instance.new("UICorner", shootButton).CornerRadius = UDim.new(0, 8)

    local controlButton = Instance.new("TextButton")
    controlButton.Size = UDim2.new(1, -20, 0, 40)
    controlButton.Position = UDim2.new(0, 10, 0, 100)
    controlButton.BackgroundColor3 = Color3.fromRGB(34, 139, 34)
    controlButton.Text = "🎭 Control Player"
    controlButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    controlButton.Font = Enum.Font.GothamBold
    controlButton.TextSize = 16
    controlButton.Parent = frame
    Instance.new("UICorner", controlButton).CornerRadius = UDim.new(0, 8)

    local function getNearestPlayer()
        local nearest = nil
        local shortestDist = math.huge
        local myChar = LocalPlayer.Character
        if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return end
        local myPos = myChar.HumanoidRootPart.Position
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (plr.Character.HumanoidRootPart.Position - myPos).Magnitude
                if dist < shortestDist then
                    shortestDist = dist
                    nearest = plr
                end
            end
        end
        return nearest
    end

    shootButton.MouseButton1Click:Connect(function()
        local nearest = getNearestPlayer()
        if nearest and nearest.Character and nearest.Character:FindFirstChild("HumanoidRootPart") then
            controlTarget = nearest
            if REUseItem then
                pcall(function()
                    REUseItem:FireServer(Vector3.new(-345, -7, 3), nearest.Character.HumanoidRootPart)
                end)
            end
            shootButton.Text = "✔ Shot: "..nearest.Name
            shootButton.BackgroundColor3 = Color3.fromRGB(0, 180, 255)
        else
            shootButton.Text = "❌ No player found"
            shootButton.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
        end
    end)

    controlButton.MouseButton1Click:Connect(function()
        if controlTarget and controlTarget.Character and not controlling then
            controlling = true
            local targetChar = controlTarget.Character
            originalChar = LocalPlayer.Character
            originalCamSubject = Camera.CameraSubject

            local targetHumanoid = targetChar:FindFirstChild("Humanoid")
            local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
            if not targetHumanoid or not targetHRP then return end

            Camera.CameraSubject = targetHumanoid
            LocalPlayer.Character = targetChar
            controlButton.Text = "🎭 Controlling..."
            controlButton.BackgroundColor3 = Color3.fromRGB(200, 200, 0)

            local bv = Instance.new("BodyVelocity")
            bv.MaxForce = Vector3.new(400000, 0, 400000)
            bv.Velocity = Vector3.zero
            bv.P = 10000
            bv.Parent = targetHRP

            local bg = Instance.new("BodyGyro")
            bg.MaxTorque = Vector3.new(0, 400000, 0)
            bg.CFrame = targetHRP.CFrame
            bg.P = 10000
            bg.Parent = targetHRP

            local moveDir = Vector3.new(0,0,0)
            local jump = false

            -- PC INPUT
            local inputConn = UserInputService.InputBegan:Connect(function(input, gp)
                if gp then return end
                if input.KeyCode == Enum.KeyCode.S then moveDir = Vector3.new(0,0,-1) end
                if input.KeyCode == Enum.KeyCode.W then moveDir = Vector3.new(0,0,1) end
                if input.KeyCode == Enum.KeyCode.A then moveDir = Vector3.new(-1,0,0) end
                if input.KeyCode == Enum.KeyCode.D then moveDir = Vector3.new(1,0,0) end
                if input.KeyCode == Enum.KeyCode.Space then jump = true end
            end)
            local inputEndConn = UserInputService.InputEnded:Connect(function(input, gp)
                if gp then return end
                if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.S or
                   input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.D then
                    moveDir = Vector3.new(0,0,0)
                end
                if input.KeyCode == Enum.KeyCode.Space then jump = false end
            end)

            -- MOBILE INPUT (D-Pad)
            createMobileControls(controlFrameRef, function(dir)
                moveDir = dir
            end, function(isJumping)
                jump = isJumping
            end)

            local moveConn
            moveConn = RunService.Heartbeat:Connect(function()
                local camCFrame = Camera.CFrame
                local dir = (camCFrame.RightVector * moveDir.X + camCFrame.LookVector * moveDir.Z)
                bv.Velocity = dir * 24 + Vector3.new(0, bv.Velocity.Y, 0)
                if jump and targetHumanoid.FloorMaterial ~= Enum.Material.Air then
                    targetHumanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
                bg.CFrame = CFrame.new(targetHRP.Position, targetHRP.Position + camCFrame.LookVector)
            end)

            task.delay(10, function()
                if controlling then
                    controlling = false
                    LocalPlayer.Character = originalChar
                    Camera.CameraSubject = originalCamSubject
                    controlButton.Text = "🎭 Control Player"
                    controlButton.BackgroundColor3 = Color3.fromRGB(34, 139, 34)
                    bv:Destroy()
                    bg:Destroy()
                    inputConn:Disconnect()
                    inputEndConn:Disconnect()
                    moveConn:Disconnect()
                end
            end)
        end
    end)
end

local function ToggleControl()
    controlToggle = not controlToggle  -- Cambia el estado (ON/OFF)

    if controlToggle then
        -- 🔵 ACTIVAR
        if not controlGuiCreated then
            createControlGui() -- Crea la GUI si no existe
        else
            if controlScreenGui then
                controlScreenGui.Enabled = true -- Solo la muestra
            end
        end
    else
        -- 🔴 DESACTIVAR
        if controlScreenGui then
            controlScreenGui.Enabled = false -- Oculta la GUI
        end
    end
end

-- ===== Air Walk =====
local airPart
local floatConn
local floatEnabled = false

-- Función toggle automática
local function ToggleFloatV1()
    floatEnabled = not floatEnabled

    if floatEnabled then
        -- Activar Float
        if not airPart then
            airPart = Instance.new("Part")
            airPart.Anchored = true
            airPart.Size = Vector3.new(6, 1, 6)
            airPart.Transparency = 1
            airPart.Color = Color3.fromRGB(0, 255, 0)
            airPart.Parent = workspace

            -- Actualizar posición
            floatConn = RunService.RenderStepped:Connect(function()
                if not airPart or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                    if floatConn then floatConn:Disconnect() end
                    return
                end
                airPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, -3, 0)
            end)
        end
    else
        -- Desactivar Float
        if floatConn then
            floatConn:Disconnect()
            floatConn = nil
        end
        if airPart then
            airPart:Destroy()
            airPart = nil
        end
    end
end

registerTab("Main", function()
	clearContent()
	print("[DEBUG] Poblando Main")
	createToggle("Infinite Jump", false, function(s) print("IJ:", s) end)
	createToggle("Walk Fling", false, function(s) print("WF:", s) end)
	createToggle("Hide under base", false, function(s) print("HUB:", s) end)
	createToggle("Anti Hit", false, function(s) print("AH:", s) end)
	createToggle("Base Protector", false, function(s) print("BP:", s) end)
end)
-- Settings
registerTab("Settings", function()
	clearContent()
	print("[DEBUG] Poblando Settings")
	createToggle("Auto Rejoin", false, function(s) end)
	createToggle("Auto Collect", true, function(s) end)
	createToggle("Low Graphics", false, function(s) end)
end)
-- ESP
registerTab("ESP", function()
	clearContent()
	print("[DEBUG] Poblando ESP")
	createToggle("ESP Timers", true, function(s) espBasesToggle(s) end)
	createToggle("ESP Players", false, function(s) toggleEspPlayers(s) end)
	createToggle("ESP Best Brainrot", false, function(s) toggleBrainrot(s) end)
end)
-- Info
registerTab("Info", function()
	clearContent()
	print("[DEBUG] Poblando Info")
	local infoFrame = new("Frame", {Size = UDim2.new(1,0,0,110), BackgroundColor3 = C.item, BorderSizePixel = 0, ZIndex = 196})
	new("UICorner", {Parent = infoFrame, CornerRadius = UDim.new(0,10)})
	local txt = new("TextLabel", {Parent = infoFrame, Size = UDim2.new(1,-24,1,-24), Position = UDim2.new(0,12,0,12), BackgroundTransparency = 1, Text = "Backdoor Hub\nVersion 1.0\nBy: You", TextColor3 = C.text, Font = Enum.Font.Gotham, TextSize = 14, TextScaled = true, TextXAlignment = Enum.TextXAlignment.Left, ZIndex = 197})
	pushContentFrame(infoFrame)
end)

-- Activate initial tab after a frame
RunService.Heartbeat:Wait()
if tabsRegistry["Main"] then
	setActiveTab("Main")
else
	warn("No se registró la tab Main")
end

-- OPEN/CLOSE with Tween
local menuOpen = false
local tweenInfo = TweenInfo.new(0.16, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
openBtn.MouseButton1Click:Connect(function()
	menuOpen = not menuOpen
	if menuOpen then
		mainOuter.Size = UDim2.new(0,0,0,0)
		mainOuter.Visible = true
		local t = TweenService:Create(mainOuter, tweenInfo, {Size = UDim2.new(0, mainW + 12, 0, mainH + 12)})
		t:Play()
	else
		local t = TweenService:Create(mainOuter, tweenInfo, {Size = UDim2.new(0,0,0,0)})
		t.Completed:Connect(function() mainOuter.Visible = false end)
		t:Play()
	end
end)
closeBtn.MouseButton1Click:Connect(function()
	if menuOpen then
		menuOpen = false
		local t = TweenService:Create(mainOuter, tweenInfo, {Size = UDim2.new(0,0,0,0)})
		t.Completed:Connect(function() mainOuter.Visible = false end)
		t:Play()
	end
end)

-- Continuous heartbeat to guarantee layout kept updated
RunService.Heartbeat:Connect(function()
	if contentLayout and contentLayout.AbsoluteContentSize then
		contentInner.Size = UDim2.new(1,0,0,contentLayout.AbsoluteContentSize.Y)
	end
	updateContentPos()
end)

print("Backdoor Hub cargado.")
