-- LocalScript (pegar en StarterPlayerScripts o StarterGui)
-- Menu "idéntico" estilo Nameless Hub, responsive, sin ScrollingFrame.
-- Toggle NO se activa al scrollear; solo se activa al presionar (tap/click).
-- ImageId del logo que abre/cierra: 73356133683404

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

---- CONFIG ------------------------------------------------
local LOGO_ASSET_ID = "rbxassetid://73356133683404"
local DRAG_THRESHOLD = 8 -- px para distinguir drag vs tap
local WHEEL_SCROLL_PIXELS = 80
local PADDING = 16
local smallScreenWidthThreshold = 900

---- HELPERS ------------------------------------------------
local function new(className, props)
	local obj = Instance.new(className)
	if props then
		for k,v in pairs(props) do
			if k == "Parent" then
				obj.Parent = v
			else
				obj[k] = v
			end
		end
	end
	return obj
end

local function isTouchOnly()
	return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
end

---- SCREEN GUI ------------------------------------------------
local screenGui = new("ScreenGui", {
	Name = "NamelessHub_GUI",
	Parent = playerGui,
	DisplayOrder = 9999,
	IgnoreGuiInset = true,
	ResetOnSpawn = false
})

---- Responsividad base ---------------------------------------
local function getViewport()
	local cam = workspace.CurrentCamera
	if cam then return cam.ViewportSize end
	return Vector2.new(1280,720)
end

local viewport = getViewport()
local smallScreen = (math.max(viewport.X, viewport.Y) < smallScreenWidthThreshold) or isTouchOnly()

local function recomputeVars()
	viewport = getViewport()
	smallScreen = (math.max(viewport.X, viewport.Y) < smallScreenWidthThreshold) or isTouchOnly()
end
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function() recomputeVars() end)
UserInputService:GetPropertyChangedSignal("TouchEnabled"):Connect(function() recomputeVars() end)

---- COLORES & ESTILO ----------------------------------------
local C = {}
C.bg = Color3.fromRGB(19, 19, 22)
C.panel = Color3.fromRGB(30, 30, 36)
C.item = Color3.fromRGB(38, 38, 44)
C.text = Color3.fromRGB(236,236,240)
C.subtext = Color3.fromRGB(170,170,180)
C.purple = Color3.fromRGB(153, 63, 211) -- morado
C.pink = Color3.fromRGB(236, 64, 122) -- rosa
C.toggleOn = Color3.fromRGB(200,200,255)

---- OPEN/CLOSE CIRCULAR BUTTON --------------------------------
local openButtonSize = smallScreen and 58 or 76
local openBtn = new("ImageButton", {
	Name = "NH_OpenButton",
	Parent = screenGui,
	Image = LOGO_ASSET_ID,
	BackgroundTransparency = 0,
	BackgroundColor3 = C.bg,
	Size = UDim2.new(0, openButtonSize, 0, openButtonSize),
	Position = UDim2.new(0, 18, 0, 24),
	AutoButtonColor = false,
	ZIndex = 100,
	ScaleType = Enum.ScaleType.Fit
})
new("UICorner", {Parent = openBtn, CornerRadius = UDim.new(1,0)})
-- Border glow ring (double stroke feel)
local openStroke = new("UIStroke", {Parent = openBtn, Color = C.pink, Thickness = 3})
openStroke.Transparency = 0.0

---- MAIN MENU FRAME (centered) --------------------------------
local mainW = smallScreen and 520 or 820
local mainH = smallScreen and 360 or 560
local mainOuter = new("Frame", {
	Name = "NH_MainOuter",
	Parent = screenGui,
	Size = UDim2.new(0, mainW + 10, 0, mainH + 10),
	Position = UDim2.new(0.5, 0, 0.5, 0),
	AnchorPoint = Vector2.new(0.5, 0.5),
	BackgroundTransparency = 1,
	ZIndex = 90,
	Visible = false
})
-- Outline (purple/pink border)
local outline = new("Frame", {
	Parent = mainOuter,
	Size = UDim2.new(1,0,1,0),
	Position = UDim2.new(0,0,0,0),
	BackgroundColor3 = C.pink,
	BorderSizePixel = 0
})
new("UICorner", {Parent = outline, CornerRadius = UDim.new(0,16)})
-- Inner main
local mainFrame = new("Frame", {
	Parent = outline,
	Size = UDim2.new(1, -8, 1, -8),
	Position = UDim2.new(0,4,0,4),
	BackgroundColor3 = C.panel,
	BorderSizePixel = 0,
	ZIndex = 91,
	ClipsDescendants = true
})
new("UICorner", {Parent = mainFrame, CornerRadius = UDim.new(0,14)})

-- Top thin purple line and header
local header = new("Frame", {
	Parent = mainFrame,
	Size = UDim2.new(1, -32, 0, 66),
	Position = UDim2.new(0,16,0,8),
	BackgroundTransparency = 1
})
local title = new("TextLabel", {
	Parent = header,
	Text = "Nameless Hub",
	BackgroundTransparency = 1,
	TextColor3 = C.text,
	Font = Enum.Font.GothamBold,
	TextSize = smallScreen and 20 or 28,
	Size = UDim2.new(1,0,1,0),
	TextXAlignment = Enum.TextXAlignment.Center
})
-- small horizontal accent line under title
local accentLine = new("Frame", {
	Parent = mainFrame,
	Size = UDim2.new(1, -40, 0, 6),
	Position = UDim2.new(0,20,0,74),
	BackgroundColor3 = C.purple,
	BorderSizePixel = 0
})
new("UICorner", {Parent = accentLine, CornerRadius = UDim.new(0,4)})

-- Close X button (top-right)
local closeBtn = new("TextButton", {
	Parent = mainFrame,
	Text = "✕",
	Font = Enum.Font.GothamBold,
	TextSize = smallScreen and 16 or 20,
	TextColor3 = C.text,
	BackgroundColor3 = Color3.fromRGB(45,45,50),
	Size = UDim2.new(0,44,0,44),
	Position = UDim2.new(1, -64, 0, 12),
	AutoButtonColor = false
})
new("UICorner", {Parent = closeBtn, CornerRadius = UDim.new(0,8)})
new("UIStroke", {Parent = closeBtn, Color = Color3.fromRGB(60,60,65), Thickness = 1})

---- LAYOUT: LEFT TABS and RIGHT CONTENT -----------------------
local leftW = smallScreen and 180 or 240
local leftCol = new("Frame", {
	Parent = mainFrame,
	Size = UDim2.new(0, leftW, 1, -110),
	Position = UDim2.new(0, 18, 0, 92),
	BackgroundColor3 = Color3.fromRGB(23,23,28),
	BorderSizePixel = 0
})
new("UICorner", {Parent = leftCol, CornerRadius = UDim.new(0,10)})

local divider = new("Frame", {
	Parent = mainFrame,
	Size = UDim2.new(0, 6, 1, -110),
	Position = UDim2.new(0, leftW + 26, 0, 92),
	BackgroundColor3 = C.purple,
	BorderSizePixel = 0
})
new("UICorner", {Parent = divider, CornerRadius = UDim.new(0,4)})

local rightCol = new("Frame", {
	Parent = mainFrame,
	Size = UDim2.new(1, - (leftW + 60), 1, -110),
	Position = UDim2.new(0, leftW + 34, 0, 92),
	BackgroundColor3 = Color3.fromRGB(28,28,33),
	BorderSizePixel = 0,
	ClipsDescendants = true
})
new("UICorner", {Parent = rightCol, CornerRadius = UDim.new(0,10)})

-- Tabs column: UIListLayout for spacing similar to image
local tabsContainer = new("Frame", {Parent = leftCol, Size = UDim2.new(1, -16, 1, -16), Position = UDim2.new(0,8,0,8), BackgroundTransparency = 1})
local tabsLayout = new("UIListLayout", {Parent = tabsContainer, Padding = UDim.new(0, 14), SortOrder = Enum.SortOrder.LayoutOrder})
tabsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
tabsLayout.VerticalAlignment = Enum.VerticalAlignment.Top

-- Content area: we will manage scrolling manually, no ScrollingFrame
local contentMask = new("Frame", {
	Parent = rightCol,
	Size = UDim2.new(1, -24, 1, -24),
	Position = UDim2.new(0, 12, 0, 12),
	BackgroundTransparency = 1,
	ClipsDescendants = true
})
local contentInner = new("Frame", {
	Parent = contentMask,
	Size = UDim2.new(1, 0, 0, 0),
	Position = UDim2.new(0, 0, 0, 0),
	BackgroundTransparency = 1
})

-- Track content offset and height
local contentOffset = 0
local contentInnerHeight = 0
local function recalcMask()
	contentMaskSizeY = contentMask.AbsoluteSize.Y
end
contentMask:GetPropertyChangedSignal("AbsoluteSize"):Connect(recalcMask)
recalcMask()

local function clampOffset(v)
	local max = math.max(0, contentInnerHeight - contentMask.AbsoluteSize.Y)
	if v > 0 then v = 0 end
	if v < -max then v = -max end
	return v
end
local function updateContentPos()
	contentOffset = clampOffset(contentOffset)
	contentInner.Position = UDim2.new(0, 0, 0, contentOffset)
end

---- TAB CREATION ------------------------------------------------
local tabs = {}
local activeTabName = nil
local tabsRegistry = {}

local function createTabButton(name)
	local btn = new("TextButton", {
		Parent = tabsContainer,
		Text = name,
		Font = Enum.Font.GothamSemibold,
		TextSize = smallScreen and 16 or 18,
		TextColor3 = C.text,
		Size = UDim2.new(1, -12, 0, smallScreen and 44 or 56),
		BackgroundColor3 = Color3.fromRGB(49,49,56),
		BorderSizePixel = 0,
		AutoButtonColor = false
	})
	new("UICorner", {Parent = btn, CornerRadius = UDim.new(0,10)})
	local stroke = new("UIStroke", {Parent = btn, Color = Color3.fromRGB(55,55,62), Thickness = 1})
	return btn
end

local function setActiveTab(name)
	-- visual update of tabs
	for k,entry in pairs(tabsRegistry) do
		local btn = entry.Button
		if k == name then
			btn.BackgroundColor3 = C.purple
			btn.TextColor3 = Color3.fromRGB(245,245,245)
		else
			btn.BackgroundColor3 = Color3.fromRGB(49,49,56)
			btn.TextColor3 = C.text
		end
	end
	activeTabName = name
	-- call onOpen to populate content
	if tabsRegistry[name] and tabsRegistry[name].onOpen then
		tabsRegistry[name].onOpen()
	end
end

---- CONTENT MANAGEMENT -----------------------------------------
local function clearContent()
	for _,v in ipairs(contentInner:GetChildren()) do
		v:Destroy()
	end
	contentInnerHeight = 0
	contentInner.Size = UDim2.new(1,0,0,0)
	contentOffset = 0
	updateContentPos()
end

local function pushContentFrame(frame)
	frame.Parent = contentInner
	frame.Position = UDim2.new(0, 0, 0, contentInnerHeight)
	contentInnerHeight = contentInnerHeight + frame.Size.Y.Offset
	contentInner.Size = UDim2.new(1, 0, 0, contentInnerHeight)
end

---- TOGGLE CREATOR (con proteccion contra scroll) --------------
local function createToggle(labelText, default, callback)
	local itemH = smallScreen and 56 or 72
	local item = new("Frame", {Size = UDim2.new(1, 0, 0, itemH), BackgroundColor3 = C.item, BorderSizePixel = 0})
	new("UICorner", {Parent = item, CornerRadius = UDim.new(0,10)})

	local lbl = new("TextLabel", {
		Parent = item,
		Size = UDim2.new(0.75, -24, 1, 0),
		Position = UDim2.new(0, 14, 0, 0),
		BackgroundTransparency = 1,
		Text = labelText,
		TextColor3 = C.text,
		Font = Enum.Font.Gotham,
		TextSize = smallScreen and 14 or 18,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	local sub = new("TextLabel", {
		Parent = item,
		Size = UDim2.new(0.75, -24, 0, 18),
		Position = UDim2.new(0, 14, 1, -22),
		BackgroundTransparency = 1,
		Text = "",
		TextColor3 = C.subtext,
		Font = Enum.Font.Gotham,
		TextSize = smallScreen and 12 or 13,
		TextXAlignment = Enum.TextXAlignment.Left
	})

	-- switch background
	local switchW = smallScreen and 56 or 78
	local switchH = smallScreen and 28 or 36
	local switchBg = new("Frame", {
		Parent = item,
		Size = UDim2.new(0, switchW, 0, switchH),
		Position = UDim2.new(1, - (switchW + 18), 0.5, -(switchH/2)),
		BackgroundColor3 = Color3.fromRGB(80,80,86),
		BorderSizePixel = 0
	})
	new("UICorner", {Parent = switchBg, CornerRadius = UDim.new(0,16)})
	local knobSize = smallScreen and 20 or 26
	local knob = new("Frame", {
		Parent = switchBg,
		Size = UDim2.new(0, knobSize, 0, knobSize),
		Position = default and UDim2.new(1, -(knobSize+6), 0.5, -(knobSize/2)) or UDim2.new(0, 6, 0.5, -(knobSize/2)),
		BackgroundColor3 = default and C.toggleOn or Color3.fromRGB(245,245,245),
		BorderSizePixel = 0,
		ZIndex = 2
	})
	new("UICorner", {Parent = knob, CornerRadius = UDim.new(1,0)})

	-- state
	local state = default

	-- Input detection: guard against scroll dragging
	local activeInput = nil
	local startPos = nil
	local isDrag = false
	local originContentOffset = 0

	local function inputBegan(input)
		if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
			activeInput = input
			startPos = input.Position
			isDrag = false
			originContentOffset = contentOffset
		end
	end

	local function inputChanged(input)
		if activeInput and input == activeInput then
			local delta = input.Position - startPos
			if math.abs(delta.Y) > DRAG_THRESHOLD then
				isDrag = true
				-- if dragging, we want to scroll the content (so toggles won't toggle)
				contentOffset = originContentOffset + delta.Y
				updateContentPos()
			end
		end
	end

	local function inputEnded(input)
		if activeInput and input == activeInput then
			if not isDrag then
				-- toggle
				state = not state
				if state then
					knob.Position = UDim2.new(1, -(knobSize+6), 0.5, -(knobSize/2))
					knob.BackgroundColor3 = C.toggleOn
				else
					knob.Position = UDim2.new(0, 6, 0.5, -(knobSize/2))
					knob.BackgroundColor3 = Color3.fromRGB(245,245,245)
				end
				if callback then
					pcall(callback, state)
				end
			end
			activeInput = nil
			startPos = nil
			isDrag = false
		end
	end

	-- Connect input events specifically to switchBg (to avoid interfering with other UI)
	switchBg.InputBegan:Connect(inputBegan)
	switchBg.InputChanged:Connect(inputChanged)
	switchBg.InputEnded:Connect(inputEnded)

	-- Also listen to global InputChanged/Ended to catch touch/mouse changes reliably
	UserInputService.InputChanged:Connect(function(inp)
		if inp == activeInput then inputChanged(inp) end
	end)
	UserInputService.InputEnded:Connect(function(inp) if inp == activeInput then inputEnded(inp) end end)

	pushContentFrame(item)
	-- return api
	return {
		GetState = function() return state end,
		SetState = function(v)
			state = v
			if state then
				knob.Position = UDim2.new(1, -(knobSize+6), 0.5, -(knobSize/2))
				knob.BackgroundColor3 = C.toggleOn
			else
				knob.Position = UDim2.new(0, 6, 0.5, -(knobSize/2))
				knob.BackgroundColor3 = Color3.fromRGB(245,245,245)
			end
		end,
		Frame = item
	}
end

---- MANUAL SCROLL: touch drag + mouse wheel ----------------------
-- drag over contentMask
do
	local active = nil
	local startY = 0
	local startOffset = 0
	contentMask.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
			active = input
			startY = input.Position.Y
			startOffset = contentOffset
			-- capture so toggles detect drag as well (they compare start pos)
		end
	end)
	contentMask.InputChanged:Connect(function(input)
		if active and input == active then
			local delta = input.Position.Y - startY
			if math.abs(delta) > DRAG_THRESHOLD then
				contentOffset = startOffset + delta
				updateContentPos()
			end
		end
	end)
	contentMask.InputEnded:Connect(function(input)
		if active and input == active then active = nil end
	end)
end

-- mouse wheel
UserInputService.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseWheel then
		local delta = input.Position.Z
		contentOffset = contentOffset + (-delta * WHEEL_SCROLL_PIXELS)
		updateContentPos()
	end
end)

---- TABS CONTENT (ejemplo igual a la imagen) --------------------
-- Register tabs: Main, Settings, ESP, Info
local function registerTab(name, onOpen)
	local btn = createTabButton(name)
	tabsRegistry[name] = {Button = btn, onOpen = onOpen}
	-- connect click
	btn.MouseButton1Click:Connect(function()
		setActiveTab(name)
	end)
end

-- Main
registerTab("Main", function()
	clearContent()
	createToggle("Infinite Jump", false, function(s) print("Infinite Jump:", s) end)
	createToggle("Walk Fling", false, function(s) print("Walk Fling:", s) end)
	createToggle("Hide under base", false, function(s) print("Hide under base:", s) end)
	createToggle("Anti Hit", false, function(s) print("Anti Hit:", s) end)
	createToggle("Base Protector", false, function(s) print("Base Protector:", s) end)
end)

-- Settings
registerTab("Settings", function()
	clearContent()
	createToggle("Auto Rejoin", false, function(s) end)
	createToggle("Auto Collect", true, function(s) end)
	createToggle("Low Graphics", false, function(s) end)
end)

-- ESP
registerTab("ESP", function()
	clearContent()
	createToggle("Show Names", true, function(s) end)
	createToggle("Show Boxes", false, function(s) end)
end)

-- Info
registerTab("Info", function()
	clearContent()
	local infoH = smallScreen and 100 or 120
	local infoFrame = new("Frame", {Size = UDim2.new(1,0,0,infoH), BackgroundColor3 = C.item, BorderSizePixel = 0})
	new("UICorner", {Parent = infoFrame, CornerRadius = UDim.new(0,10)})
	local txt = new("TextLabel", {
		Parent = infoFrame,
		Size = UDim2.new(1, -24, 1, -24),
		Position = UDim2.new(0, 12, 0, 12),
		BackgroundTransparency = 1,
		Text = "Nameless Hub\nVersion 1.0\nBy: You",
		TextColor3 = C.text,
		Font = Enum.Font.Gotham,
		TextSize = smallScreen and 12 or 16,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	pushContentFrame(infoFrame)
end)

-- Set initial tab
setActiveTab("Main")

---- OPEN / CLOSE BEHAVIOR (con Tween para suavidad) ------------
local menuOpen = false
local tweenInfo = TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
openBtn.MouseButton1Click:Connect(function()
	menuOpen = not menuOpen
	mainOuter.Visible = menuOpen
	-- pequeña animacion de escala
	if menuOpen then
		mainOuter.Size = UDim2.new(0, 0, 0, 0)
		mainOuter.Visible = true
		local t = TweenService:Create(mainOuter, tweenInfo, {Size = UDim2.new(0, mainW + 10, 0, mainH + 10)})
		t:Play()
	else
		local t = TweenService:Create(mainOuter, tweenInfo, {Size = UDim2.new(0, 0, 0, 0)})
		t.Completed:Connect(function() mainOuter.Visible = false end)
		t:Play()
	end
end)

closeBtn.MouseButton1Click:Connect(function()
	if menuOpen then
		menuOpen = false
		local t = TweenService:Create(mainOuter, tweenInfo, {Size = UDim2.new(0, 0, 0, 0)})
		t.Completed:Connect(function() mainOuter.Visible = false end)
		t:Play()
	end
end)

-- Ensure open button is visible on all screen sizes and reposition if needed
local function updatePositions()
	openBtn.Size = UDim2.new(0, smallScreen and 58 or 76, 0, smallScreen and 58 or 76)
	mainOuter.Size = UDim2.new(0, mainW + 10, 0, mainH + 10)
	mainFrame.Size = UDim2.new(1, -8, 1, -8)
end
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(updatePositions)
updatePositions()

print("Nameless Hub GUI cargado y listo.")
