local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Config
local LOGO_ASSET_ID = "rbxassetid://73356133683404" -- tu id
local DRAG_THRESHOLD = 8 -- px: si el movimiento excede esto se considera scroll/drag
local SCROLL_SPEED_WHEEL = 60 -- px per wheel tick

-- Detectar si dispositivo táctil
local isTouchDevice = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- Helper para crear instances
local function new(className, props)
	local obj = Instance.new(className)
	if props then
		for k,v in pairs(props) do
			if k == "Parent" then
				obj.Parent = v
			else
				obj[k] = v
			end
		end
	end
	return obj
end

-- Root ScreenGui
local player = game:GetService("Players").LocalPlayer
local screenGui = new("ScreenGui", {
    Name = "NamelessHubGUI",
    ResetOnSpawn = false,
    Parent = player:WaitForChild("PlayerGui")
})

-- Responsive scale depending on screen size
local screenSize = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1280,720)
local smallScreen = math.max(screenSize.X, screenSize.Y) < 900 or isTouchDevice

-- Styles (colores aproximados)
local colors = {
	bg = Color3.fromRGB(26, 25, 30),
	panel = Color3.fromRGB(30,30,35),
	accent1 = Color3.fromRGB(204, 47, 120),
	accent2 = Color3.fromRGB(90,45,170),
	item = Color3.fromRGB(45,45,50),
	text = Color3.fromRGB(227,227,230),
	subtext = Color3.fromRGB(170,170,176),
	switchBg = Color3.fromRGB(72,72,78),
	switchOn = Color3.fromRGB(160,160,255)
}

-- Open/Close circular button (logo)
local openButton = new("ImageButton", {
	Name = "OpenButton",
	Parent = screenGui,
	Image = LOGO_ASSET_ID,
	BackgroundTransparency = 1,
	Size = UDim2.new(0, smallScreen and 62 or 78, 0, smallScreen and 62 or 78),
	Position = UDim2.new(0, 20, 0, 18),
	AnchorPoint = Vector2.new(0,0),
	ZIndex = 5,
	ScaleType = Enum.ScaleType.Fit
})
-- Ring behind for border
local openRing = new("Frame", {
	Parent = openButton,
	Size = UDim2.new(1,6,1,6),
	Position = UDim2.new(0,-3,0,-3),
	BackgroundTransparency = 1,
	ZIndex = 4
})
local ringUICorner = new("UICorner", {Parent = openButton, CornerRadius = UDim.new(1,0)})

-- Main menu frame (initially hidden)
local mainFrame = new("Frame", {
	Name = "MainFrame",
	Parent = screenGui,
	Size = UDim2.new(0, smallScreen and 520 or 820, 0, smallScreen and 360 or 560),
	Position = UDim2.new(0.5, 0, 0.5, 0),
	AnchorPoint = Vector2.new(0.5,0.5),
	BackgroundColor3 = colors.panel,
	BorderSizePixel = 0,
	ZIndex = 4,
	Visible = false,
	ClipsDescendants = true
})
new("UICorner", {Parent = mainFrame, CornerRadius = UDim.new(0,14)})
-- Outer gradient accent top
local topAccent = new("Frame", {
	Parent = mainFrame,
	Size = UDim2.new(1,0,0,8),
	Position = UDim2.new(0,0,0,0),
	BackgroundColor3 = colors.accent1,
	BorderSizePixel = 0,
	ZIndex = 6
})
new("UICorner", {Parent = topAccent, CornerRadius = UDim.new(0,6)})

-- Header
local header = new("Frame", {
	Parent = mainFrame,
	Size = UDim2.new(1,-20,0,60),
	Position = UDim2.new(0,10,0,8),
	BackgroundTransparency = 1
})
local headerText = new("TextLabel", {
	Parent = header,
	Text = "Nameless Hub",
	TextColor3 = colors.text,
	Font = Enum.Font.GothamBold,
	TextSize = smallScreen and 20 or 28,
	BackgroundTransparency = 1,
	Position = UDim2.new(0,0,0,0),
	Size = UDim2.new(0.7,0,1,0),
	TextXAlignment = Enum.TextXAlignment.Left
})
-- Close button on header
local closeBtn = new("TextButton", {
	Parent = header,
	Text = "✕",
	Font = Enum.Font.GothamBold,
	TextSize = smallScreen and 18 or 22,
	BackgroundTransparency = 0.9,
	Size = UDim2.new(0,38,0,38),
	Position = UDim2.new(1,-38,0,4),
	TextColor3 = colors.text
})
new("UICorner", {Parent = closeBtn, CornerRadius = UDim.new(0,8)})

-- Layout: left tabs column and right content column
local leftCol = new("Frame", {
	Parent = mainFrame,
	Size = UDim2.new(0, smallScreen and 140 or 200, 1, -80),
	Position = UDim2.new(0,12,0,72),
	BackgroundColor3 = colors.bg,
	BorderSizePixel = 0
})
new("UICorner", {Parent = leftCol, CornerRadius = UDim.new(0,10)})
local rightCol = new("Frame", {
	Parent = mainFrame,
	Size = UDim2.new(1, - (smallScreen and 170 or 240), 1, -80),
	Position = UDim2.new(0, (smallScreen and 170 or 240), 0, 72),
	BackgroundColor3 = Color3.fromRGB(22,22,26),
	BorderSizePixel = 0,
	ClipsDescendants = true
})
new("UICorner", {Parent = rightCol, CornerRadius = UDim.new(0,10)})

-- Left tabs list
local tabsList = new("Frame", {
	Parent = leftCol,
	Size = UDim2.new(1,0,1,0),
	BackgroundTransparency = 1
})
local tabsLayout = new("UIListLayout", {
	Parent = tabsList,
	Padding = UDim.new(0, 14),
	SortOrder = Enum.SortOrder.LayoutOrder
})
tabsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
tabsLayout.VerticalAlignment = Enum.VerticalAlignment.Top
tabsLayout.Padding = UDim.new(0, 12)

-- Right content container (no ScrollingFrame)
local contentMask = new("Frame", {
	Parent = rightCol,
	Size = UDim2.new(1, -16, 1, -16),
	Position = UDim2.new(0, 8, 0, 8),
	BackgroundTransparency = 1,
	ClipsDescendants = true
})
local contentInner = new("Frame", {
	Parent = contentMask,
	Size = UDim2.new(1, 0, 0, 0), -- height will be updated según items
	Position = UDim2.new(0, 0, 0, 0),
	BackgroundTransparency = 1
})

-- Track content offset in pixels
local contentOffset = 0
local contentInnerHeight = 0
local contentMaskSizeY = 0
local function recalcMaskSize()
	contentMaskSizeY = contentMask.AbsoluteSize.Y
end
contentMask:GetPropertyChangedSignal("AbsoluteSize"):Connect(recalcMaskSize)
recalcMaskSize()

-- Función para actualizar posicion de contentInner según contentOffset, con clamps
local function clampContentOffset(v)
	local maxOffset = math.max(0, contentInnerHeight - contentMaskSizeY)
	if v < -maxOffset then v = -maxOffset end
	if v > 0 then v = 0 end
	return v
end
local function updateContentPosition()
	contentOffset = clampContentOffset(contentOffset)
	contentInner.Position = UDim2.new(0, 0, 0, contentOffset)
end

-- Helper: crear una tab izquierda
local tabs = {}
local activeTab = nil
local function createTab(name)
	local btn = new("TextButton", {
		Parent = tabsList,
		Text = name,
		Size = UDim2.new(1, -18, 0, smallScreen and 42 or 56),
		BackgroundColor3 = Color3.fromRGB(47,47,52),
		TextColor3 = colors.text,
		Font = Enum.Font.GothamBold,
		TextSize = smallScreen and 16 or 18,
		AutoButtonColor = false,
		BorderSizePixel = 0
	})
	new("UICorner", {Parent = btn, CornerRadius = UDim.new(0,8)})
	btn.MouseButton1Click:Connect(function()
		-- switch tab
		for _,t in ipairs(tabs) do
			t.Button.BackgroundColor3 = Color3.fromRGB(47,47,52)
		end
		btn.BackgroundColor3 = colors.accent2
		activeTab = name
		-- show tab content
		if tabsIndex[name] and tabsIndex[name].onOpen then
			tabsIndex[name].onOpen()
		end
	end)
	local entry = {Name = name, Button = btn}
	table.insert(tabs, entry)
	return entry
end

-- Storage for tabs content builders
tabsIndex = {}

-- Función para limpiar el contentInner
local function clearContent()
	for _,c in ipairs(contentInner:GetChildren()) do
		c:Destroy()
	end
	contentInnerHeight = 0
	contentInner.Size = UDim2.new(1,0,0,0)
	contentOffset = 0
	updateContentPosition()
end

-- Función para crear un item visual (container) y ajustar contentInnerHeight
local function pushContent(itemFrame)
	itemFrame.Parent = contentInner
	-- position based on current contentInnerHeight
	itemFrame.Position = UDim2.new(0, 0, 0, contentInnerHeight)
	contentInnerHeight = contentInnerHeight + itemFrame.Size.Y.Offset
	contentInner.Size = UDim2.new(1, 0, 0, contentInnerHeight)
end

-- createToggle: crea toggle y lo añade al contentInner
-- label (string), default (bool), callback(state)
local function createToggle(label, default, callback)
	local itemHeight = smallScreen and 56 or 72
	local item = new("Frame", {
		Size = UDim2.new(1, 0, 0, itemHeight),
		BackgroundColor3 = colors.item,
		BorderSizePixel = 0
	})
	new("UICorner", {Parent = item, CornerRadius = UDim.new(0,10)})
	local lbl = new("TextLabel", {
		Parent = item,
		Text = label,
		BackgroundTransparency = 1,
		Size = UDim2.new(0.7, -16, 1, 0),
		Position = UDim2.new(0, 14, 0, 0),
		TextColor3 = colors.text,
		Font = Enum.Font.Gotham,
		TextSize = smallScreen and 14 or 18,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	local sub = new("TextLabel", {
		Parent = item,
		Text = "",
		BackgroundTransparency = 1,
		Size = UDim2.new(0.7, -16, 1, 0),
		Position = UDim2.new(0, 14, 0, itemHeight - 20),
		TextColor3 = colors.subtext,
		Font = Enum.Font.Gotham,
		TextSize = smallScreen and 11 or 13,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	-- Switch visual
	local switchBg = new("Frame", {
		Parent = item,
		Size = UDim2.new(0, smallScreen and 48 or 64, 0, smallScreen and 26 or 34),
		Position = UDim2.new(1, -(smallScreen and 66 or 80), 0.5, -(smallScreen and 13 or 17)),
		BackgroundColor3 = colors.switchBg,
		BorderSizePixel = 0,
		ZIndex = 3
	})
	new("UICorner", {Parent = switchBg, CornerRadius = UDim.new(0,16)})
	local knob = new("Frame", {
		Parent = switchBg,
		Size = UDim2.new(0, (smallScreen and 20 or 26), 0, (smallScreen and 20 or 26)),
		Position = default and UDim2.new(1, -((smallScreen and 20 or 26) + 4), 0.5, -((smallScreen and 10 or 13))) or UDim2.new(0, 4, 0.5, -((smallScreen and 10 or 13))),
		BackgroundColor3 = default and colors.switchOn or Color3.fromRGB(245,245,245),
		ZIndex = 4
	})
	new("UICorner", {Parent = knob, CornerRadius = UDim.new(1,0)})
	-- Internal state
	local state = default

	-- Input handling: queremos evitar toggles al hacer drag scroll.
	-- Lógica: cuando el usuario inicia input en el switch, registrar start position.
	-- Si durante InputChanged el movimiento supera DRAG_THRESHOLD => es drag y NO togglear.
	-- Cuando InputEnded: si no fue drag -> toggle estado.
	local activeInput = nil
	local startPos = nil
	local isDrag = false
	local originContentOffset = 0
	local function onInputBegan(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			activeInput = input
			isDrag = false
			startPos = input.Position
			originContentOffset = contentOffset
		end
	end
	local function onInputChanged(input)
		if activeInput and input.UserInputType == activeInput.UserInputType and input == activeInput then
			local delta = input.Position - startPos
			if math.abs(delta.Y) > DRAG_THRESHOLD then
				isDrag = true
				-- scroll content by moving contentOffset accordingly
				contentOffset = originContentOffset + delta.Y
				updateContentPosition()
			end
		end
	end
	local function onInputEnded(input)
		if activeInput and input == activeInput then
			if not isDrag then
				-- toggle
				state = not state
				-- animate switch (simple instant)
				if state then
					knob.Position = UDim2.new(1, -((smallScreen and 20 or 26) + 4), 0.5, -((smallScreen and 10 or 13)))
					knob.BackgroundColor3 = colors.switchOn
				else
					knob.Position = UDim2.new(0, 4, 0.5, -((smallScreen and 10 or 13)))
					knob.BackgroundColor3 = Color3.fromRGB(245,245,245)
				end
				-- callback
				if callback then
					pcall(callback, state)
				end
			end
			activeInput = nil
			startPos = nil
			isDrag = false
		end
	end

	-- Conectar eventos de input
	switchBg.InputBegan:Connect(onInputBegan)
	switchBg.InputChanged:Connect(onInputChanged)
	switchBg.InputEnded:Connect(onInputEnded)
	-- También escuchar cambios globales (touch/mouse moved)
	UserInputService.InputChanged:Connect(function(input)
		-- mouse wheel handled globally
		onInputChanged(input)
	end)
	UserInputService.InputEnded:Connect(function(input) onInputEnded(input) end)

	pushContent(item)
	-- retornar referencia por si el usuario quiere manipularlo
	return {
		Frame = item,
		GetState = function() return state end,
		SetState = function(v)
			state = v
			if state then
				knob.Position = UDim2.new(1, -((smallScreen and 20 or 26) + 4), 0.5, -((smallScreen and 10 or 13)))
				knob.BackgroundColor3 = colors.switchOn
			else
				knob.Position = UDim2.new(0, 4, 0.5, -((smallScreen and 10 or 13)))
				knob.BackgroundColor3 = Color3.fromRGB(245,245,245)
			end
		end
	}
end

-- Soporte para scroll con rueda del mouse
UserInputService.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseWheel then
		local delta = input.Position.Z -- wheel delta
		contentOffset = contentOffset + (-delta * SCROLL_SPEED_WHEEL)
		updateContentPosition()
	end
end)

-- Drag overall content by touching anywhere in contentMask
do
	local active = nil
	local startY = 0
	local startOffset = 0
	UserInputService.InputBegan:Connect(function(input, processed)
		if processed then return end
		if (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1) then
			-- check if input started inside contentMask
			local absPos = input.Position
			local guiPos = contentMask.AbsolutePosition
			local guiSize = contentMask.AbsoluteSize
			if absPos.X >= guiPos.X and absPos.X <= guiPos.X + guiSize.X and absPos.Y >= guiPos.Y and absPos.Y <= guiPos.Y + guiSize.Y then
				active = input
				startY = absPos.Y
				startOffset = contentOffset
			end
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if active and input == active and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
			local delta = input.Position.Y - startY
			if math.abs(delta) > DRAG_THRESHOLD then
				contentOffset = startOffset + delta
				updateContentPosition()
			end
		end
	end)
	UserInputService.InputEnded:Connect(function(input)
		if active and input == active then
			active = nil
		end
	end)
end

-- Crear pestañas y su contenido (ejemplo)
local tabMain = createTab("Main")
tabsIndex["Main"] = {
	onOpen = function()
		clearContent()
		-- Ejemplo de toggles parecidos a la imagen
		createToggle("Infinite Jump", false, function(state) print("Infinite Jump ->", state) end)
		createToggle("Walk Fling", false, function(state) print("Walk Fling ->", state) end)
		createToggle("Hide under base", false, function(state) print("Hide under base ->", state) end)
		createToggle("Anti Hit", false, function(state) print("Anti Hit ->", state) end)
		createToggle("Base Protector", false, function(state) print("Base Protector ->", state) end)
	end
}

local tabSettings = createTab("Settings")
tabsIndex["Settings"] = {
	onOpen = function()
		clearContent()
		createToggle("Auto Rejoin", false, function(s) print("Auto Rejoin", s) end)
		createToggle("Auto Collect", true, function(s) print("Auto Collect", s) end)
		createToggle("FPS Saver", false, function(s) print("FPS Saver", s) end)
	end
}

local tabESP = createTab("ESP")
tabsIndex["ESP"] = {
	onOpen = function()
		clearContent()
		createToggle("Show Names", true, function(s) end)
		createToggle("Show Boxes", false, function(s) end)
	end
}

local tabInfo = createTab("Info")
tabsIndex["Info"] = {
	onOpen = function()
		clearContent()
		-- info item (no toggle)
		local infoItem = new("Frame", {
			Size = UDim2.new(1,0,0, (smallScreen and 80 or 120)),
			BackgroundColor3 = colors.item
		})
		new("UICorner", {Parent = infoItem, CornerRadius = UDim.new(0,10)})
		local t = new("TextLabel", {
			Parent = infoItem,
			Size = UDim2.new(1, -20, 1, -20),
			Position = UDim2.new(0, 10, 0, 10),
			BackgroundTransparency = 1,
			Text = "Nameless Hub\nVersion 1.0\nBy: You",
			TextColor3 = colors.text,
			TextSize = smallScreen and 12 or 16,
			Font = Enum.Font.GothamBold,
			TextXAlignment = Enum.TextXAlignment.Left
		})
		pushContent(infoItem)
	end
}

-- Initially open the first tab
if #tabs > 0 then
	local first = tabs[1]
	first.Button.BackgroundColor3 = colors.accent2
	activeTab = first.Name
	if tabsIndex[first.Name] and tabsIndex[first.Name].onOpen then
		tabsIndex[first.Name].onOpen()
	end
end

-- Open/Close animations (simple)
local menuOpen = false
local function openMenu()
	mainFrame.Visible = true
	menuOpen = true
end
local function closeMenu()
	mainFrame.Visible = false
	menuOpen = false
end

openButton.MouseButton1Click:Connect(function()
	if menuOpen then
		closeMenu()
	else
		openMenu()
	end
end)
closeBtn.MouseButton1Click:Connect(function() closeMenu() end)

-- Make tabs keyboard accessible (numbers 1-4)
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local key = input.KeyCode
		if key == Enum.KeyCode.One and tabs[1] then tabs[1].Button:Activate() end
		if key == Enum.KeyCode.Two and tabs[2] then tabs[2].Button:Activate() end
		if key == Enum.KeyCode.Three and tabs[3] then tabs[3].Button:Activate() end
		if key == Enum.KeyCode.Four and tabs[4] then tabs[4].Button:Activate() end
		if key == Enum.KeyCode.Backspace then closeMenu() end
	end
end)

-- Ajustes responsivos al redimensionar pantalla
local function recomputeSizes()
	local vs = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1280,720)
	smallScreen = math.max(vs.X, vs.Y) < 900 or UserInputService.TouchEnabled
	-- update sizes quickly (minimal)
	openButton.Size = UDim2.new(0, smallScreen and 62 or 78, 0, smallScreen and 62 or 78)
	mainFrame.Size = UDim2.new(0, smallScreen and 520 or 820, 0, smallScreen and 360 or 560)
	headerText.TextSize = smallScreen and 20 or 28
end
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(recomputeSizes)
recomputeSizes()

-- FIN del script
print("Nameless Hub GUI cargado.")
